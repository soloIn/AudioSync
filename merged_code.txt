

// ===============================
// FILE: ./AudioSync/AppleMusic/IDFetcher.swift
// ===============================
import AppKit
import Foundation

// MARK: - 1. JSON è§£ææ¨¡å‹
/// ç”¨äºè§£æ iTunes Search API å“åº”çš„ç»“æ„ä½“ã€‚æˆ‘ä»¬åªéœ€è¦ Artist IDã€‚
struct ArtistSearchResult: Decodable {
    let results: [Artist]

    struct Artist: Decodable {
        let artistId: Int
        let artistName: String
        // å…è®¸è·å–å…¶ä»–ä¿¡æ¯ï¼Œå¦‚å•†åº—ä»£ç ï¼Œä½†æˆ‘ä»¬åªèšç„¦äº ID
    }
}
struct SongSearchResult: Decodable {
    let results: [SongSearchResult.Song]

    struct Song: Decodable {
        let artistId: Int
        let trackId: Int
        let artistName: String
        let trackName: String
        let collectionName: String
        let artworkUrl: String

        enum CodingKeys: String, CodingKey {
            case artistId, trackId, artistName, trackName, collectionName
            case artworkUrl = "artworkUrl100"
        }
    }
}
// MARK: - 2. å¯¼èˆªè¾…åŠ©æšä¸¾
public enum IDFetchError: Error, LocalizedError {
    case networkError(Error)
    case dataParsingError
    case NotFound
    case invalidURL

    public var errorDescription: String? {
        switch self {
        case .networkError(let error):
            return "ç½‘ç»œè¯·æ±‚å¤±è´¥: \(error.localizedDescription)"
        case .dataParsingError:
            return "æ•°æ®è§£æå¤±è´¥ï¼ŒJSONç»“æ„å¯èƒ½å·²æ›´æ”¹ã€‚"
        case .NotFound:
            return "æœªæ‰¾åˆ°åŒ¹é…çš„è‰ºæœ¯å®¶æˆ–æ­Œæ›²ã€‚"
        case .invalidURL:
            return "URL æ„é€ å¤±è´¥ã€‚"
        }
    }
}
// MARK: - 3. ID è·å–å™¨
public enum IDFetcher {
    private static let itunesSongCacheActor = ItunesSongCache()
    private static func safeCacheKey(
        for name: String,
        artist: String,
        countryCode: String
    ) -> String {
        let rawKey =
            "\(name.lowercased())_\(artist.lowercased())_\(countryCode.lowercased())"
        if let data = rawKey.data(using: .utf8) {
            return data.base64EncodedString()
        }
        return rawKey
    }
    public static func fetchArtistID(
        name: String,
        artist: String,
        countryCode: String = "cn"
    ) async throws -> Int {
        let song = try await fetchSong(by: name, by: artist)
        return song.artistId
    }

    public static func fetchTrackID(
        name: String,
        artist: String,
        countryCode: String = "cn"
    ) async throws -> Int {
        let song = try await fetchSong(by: name, by: artist)
        return song.trackId
    }

    public static func fetchArtworkData(
        name: String,
        artist: String,
        countryCode: String = "cn"
    ) async throws -> NSImage {
        let song = try await fetchSong(by: name, by: artist)
        // 1. æ„é€  URL
        guard let url = URL(string: song.artworkUrl) else {
            throw IDFetchError.invalidURL
        }

        // 2. ä¸‹è½½å›¾ç‰‡æ•°æ®
        let (data, _) = try await URLSession.shared.data(from: url)

        // âœ… ä¼˜åŒ–ç‚¹ï¼šä¸è¦ç›´æ¥è¿”å›åŸå§‹å¤§å›¾
        guard let originalImage = NSImage(data: data) else {
            throw IDFetchError.dataParsingError
        }

        // å®šä¹‰ä¸€ä¸ªåˆé€‚çš„æœ€å¤§å°ºå¯¸ï¼Œä¾‹å¦‚ 600px
        let targetSize = NSSize(width: 200, height: 200)

        // å¦‚æœåŸå›¾æ¯”ç›®æ ‡å°ºå¯¸å°ï¼Œç›´æ¥è¿”å›ï¼›å¦åˆ™è¿›è¡Œç¼©æ”¾
        if originalImage.size.width <= targetSize.width {
            return originalImage
        } else {
            return originalImage.resized(to: targetSize) ?? originalImage
        }
    }
    private static func fetchSong(
        by name: String,
        by artist: String,
        countryCode: String = "cn"
    ) async throws -> SongSearchResult.Song {

        let cacheKey = safeCacheKey(
            for: name,
            artist: artist,
            countryCode: countryCode
        )
        // 1. å…ˆæ£€æŸ¥ç¼“å­˜
        if let cachedSong = await itunesSongCacheActor.get(for: cacheKey) {
            Log.backend.debug("å‘½ä¸­ç¼“å­˜:\(name) - \(artist)")
            return cachedSong
        }

        // 2. å†æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡
        if let ongoingTask = await itunesSongCacheActor.task(for: cacheKey) {
            return try await ongoingTask.value
        }
        // 3. å¦‚æœæ²¡æœ‰ï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°ä»»åŠ¡
        let task = Task<SongSearchResult.Song, Error> {
            defer {
                Task { await itunesSongCacheActor.removeTask(for: cacheKey) }
            }

            let song = try await fetchSongFromNetwork(
                name: name,
                artist: artist,
                countryCode: countryCode
            )

            await itunesSongCacheActor.set(song, for: cacheKey)
            return song
        }

        // 4. ä¿å­˜ä»»åŠ¡åˆ° actor
        await itunesSongCacheActor.setTask(task, for: cacheKey)

        // 5. ç­‰å¾…ä»»åŠ¡å®Œæˆ
        return try await task.value
    }
    private static func fetchSongFromNetwork(
        name: String,
        artist: String,
        countryCode: String = "cn"
    ) async throws -> SongSearchResult.Song {
        // 1. URL æ„é€ 
        let baseURL = "https://itunes.apple.com/search"

        // å¯¹åå­—è¿›è¡Œ URL ç¼–ç ï¼Œä»¥å¤„ç†ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
        let term = "\(name) \(artist)"
        guard
            let encodedTerm = term.addingPercentEncoding(
                withAllowedCharacters: .urlQueryAllowed
            )
        else {
            throw IDFetchError.invalidURL
        }

        // è®¾ç½®æœç´¢å‚æ•°: term=è‰ºæœ¯å®¶åå­—, entity=allArtist, media=music, limit=1
        let urlString =
            "\(baseURL)?term=\(encodedTerm)&entity=musicTrack&media=music&limit=1&country=\(countryCode)"

        guard let url = URL(string: urlString) else {
            throw IDFetchError.invalidURL
        }

        Log.backend.debug("æ­£åœ¨æŸ¥è¯¢ iTunes Search API: \(url.absoluteString)")

        // 2. ç½‘ç»œè¯·æ±‚
        let (data, _) = try await withCheckedThrowingContinuation {
            (continuation: CheckedContinuation<(Data, URLResponse), Error>) in
            // ä½¿ç”¨ URLSession å‘èµ·è¯·æ±‚
            let task = URLSession.shared.dataTask(with: url) {
                data,
                response,
                error in
                if let error = error {
                    continuation.resume(
                        throwing: IDFetchError.networkError(error)
                    )
                    return
                }
                guard let data = data else {
                    continuation.resume(throwing: IDFetchError.dataParsingError)
                    return
                }
                continuation.resume(returning: (data, response!))
            }
            task.resume()
        }

        // 3. JSON è§£æ
        do {
            let decoder = JSONDecoder()
            let songResult = try decoder.decode(
                SongSearchResult.self,
                from: data
            )

            guard let firstSong = songResult.results.first else {
                throw IDFetchError.NotFound
            }
            return firstSong

        } catch {
            // å¯èƒ½æ˜¯ JSON è§£ç é”™è¯¯æˆ–è‰ºæœ¯å®¶æœªæ‰¾åˆ°
            if error is IDFetchError {
                throw error
            }
            throw IDFetchError.dataParsingError
        }
    }
}
extension NSImage {
    func resized(to newSize: NSSize) -> NSImage? {
        let newImage = NSImage(size: newSize)
        newImage.lockFocus()

        let sourceRect = NSRect(origin: .zero, size: self.size)
        let destRect = NSRect(origin: .zero, size: newSize)

        self.draw(
            in: destRect,
            from: sourceRect,
            operation: .copy,
            fraction: 1.0
        )

        newImage.unlockFocus()
        return newImage
    }
}


// ===============================
// FILE: ./AudioSync/AppleMusic/MusicNavigator.swift
// ===============================
import AppKit  // ç”¨äº NSWorkspace
import Foundation

/// å°è£…äº†ä¸ Apple Music App äº¤äº’çš„å¯¼èˆªåŠŸèƒ½ã€‚
public enum MusicNavigator {

    /// é”™è¯¯ç±»å‹
    public enum NavigationError: Error {
        case appleScriptError(String)
        case invalidURL
    }
    /**
     ä½¿ç”¨ URL Scheme ç›´æ¥æ‰“å¼€ä¸€ä½è‰ºæœ¯å®¶çš„ Apple Music ä¸»é¡µã€‚
    
     - Parameter artistID: è‰ºæœ¯å®¶çš„æ•°å­— IDã€‚
     - Throws: å¦‚æœ URL æ„é€ å¤±è´¥ï¼Œåˆ™æŠ›å‡º `NavigationError.invalidURL`ã€‚
     - Returns: Bool - `NSWorkspace` çš„ `open` å‡½æ•°çš„è¿”å›å€¼ã€‚
     */
    public static func openArtistPage(
        by artistID: String,
        storefrontCode: String = "cn"
    ) throws -> Bool {

        // æ„å»º Universal Link (HTTPS)
        // ä½¿ç”¨å ä½ç¬¦ 'artist-name'ï¼Œå› ä¸º OS ä¸»è¦æ˜¯çœ‹ ID
        // '?app=music' æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æç¤ºï¼Œç¡®ä¿ç³»ç»Ÿè°ƒç”¨ Music App
        let urlString =
            "https://music.apple.com/\(storefrontCode)/artist/\(artistID)?app=music"

        guard let url = URL(string: urlString) else {
            Log.backend.error("é”™è¯¯: æ— æ³•æ„é€  URL: \(urlString)")
            throw NavigationError.invalidURL
        }

        print("æ­£åœ¨å°è¯•æ‰“å¼€ Universal Link: \(url.absoluteString)")

        // NSWorkspace è´Ÿè´£å°†è¿™ä¸ª HTTPS é“¾æ¥è¯†åˆ«ä¸º Universal Linkï¼Œå¹¶æ‰“å¼€ Music.app
        return NSWorkspace.shared.open(url)
    }
}


// ===============================
// FILE: ./AudioSync/AudioSyncApp.swift
// ===============================
//
//  AudioSyncApp.swift
//  AudioSync
//
//  Created by solo on 4/29/25.
//

import AppKit
import CoreAudio
import Foundation
import SwiftData
import SwiftUI

@main
struct AudioSyncApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @ObservedObject var viewModel = ViewModel.shared
    @AppStorage("isKaraokeVisible") var isKaraokeVisible: Bool = false
    @AppStorage("isShowLoginView") var isShowLoginView: Bool = false
    @AppStorage("isAudioSwitch") var isAudioSwitch: Bool = true
    @State var isFullScreenVisible: Bool = false
    @State var karaoKeWindow: NSWindow? = nil
    @State var selectorWindow: NSWindow? = nil
    @State var similarArtistWindow: NSWindow? = nil
    @Environment(\.openWindow) var openWindow
    @ObservedObject var audioManager = AudioFormatManager.shared
    init() {
        appDelegate.modelContainer = sharedModelContainer
    }
    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            Song.self

        ])
        let modelConfiguration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: false
        )
        do {
            return try ModelContainer(
                for: schema,
                configurations: [modelConfiguration]
            )
        } catch {
            fatalError("Could not create ModelContainer: \(error)")
        }
    }()

    private func CreateKaraoke() {
        if isKaraokeVisible && !isFullScreenVisible
            && viewModel.isViewLyricsShow
        {
            if karaoKeWindow == nil {
                let contentView = NSHostingView(
                    rootView: KaraokeView().environmentObject(viewModel)
                )
                karaoKeWindow = NSWindow(
                    contentRect: NSRect(x: 0, y: 100, width: 800, height: 100),
                    styleMask: [.borderless],
                    backing: .buffered,
                    defer: false
                )

                karaoKeWindow?.contentView = contentView
                karaoKeWindow?.isOpaque = false
                karaoKeWindow?.backgroundColor = .clear
                karaoKeWindow?.level = .floating

                if let screenFrame = NSScreen.main?.visibleFrame {
                    let windowHeight: CGFloat = 100
                    let windowY = screenFrame.minY
                    let windowX = (screenFrame.width - 800) / 2
                    karaoKeWindow?.setFrame(
                        NSRect(
                            x: windowX,
                            y: windowY,
                            width: 800,
                            height: windowHeight
                        ),
                        display: false
                    )
                }

                karaoKeWindow?.isMovableByWindowBackground = true
            }
            karaoKeWindow?.orderFrontRegardless()
        } else {
            karaoKeWindow?.orderOut(nil)
        }
    }

    private func showSimilarArtistWindow() {
        viewModel.refreshSimilarArtist = true
        if similarArtistWindow == nil {
            let contentView = NSHostingView(
                rootView: SimilarArtistView()
                    .environmentObject(viewModel)
            )

            let window = NSWindow(
                contentRect: NSRect(x: 0, y: 0, width: 250, height: 400),
                styleMask: [.titled, .closable],
                backing: .buffered,
                defer: false
            )
            // window.title = "ç›¸ä¼¼æ­Œæ‰‹"
            window.center()
            window.contentView = contentView
            window.level = .floating  // ğŸ”¹å…³é”®ï¼šæµ®åŠ¨åœ¨å…¶ä»–åº”ç”¨å‰
            //window.isMovableByWindowBackground = true
            window.isReleasedWhenClosed = false
            window.makeKeyAndOrderFront(nil)
            NSApp.activate(ignoringOtherApps: true)  // ä¿è¯å‡ºç°åœ¨æœ€å‰

            similarArtistWindow = window
        } else {
            similarArtistWindow?.makeKeyAndOrderFront(nil)
            NSApp.activate(ignoringOtherApps: true)
        }
    }
    private func createLyricsManualView(needNanualSelection: Bool) {
        if needNanualSelection {
            if selectorWindow == nil {
                let contentView = NSHostingView(
                    rootView: LyricsSelectorView().environmentObject(
                        viewModel
                    )
                )
                selectorWindow = NSWindow(
                    contentRect: NSRect(x: 0, y: 450, width: 450, height: 450),
                    styleMask: [.borderless],  // æ— è¾¹æ¡†
                    backing: .buffered,
                    defer: false
                )
                selectorWindow?.contentView = contentView
                selectorWindow?.isOpaque = false
                selectorWindow?.backgroundColor = .clear
                selectorWindow?.level = .floating  // åç»­ä¼šä¿®æ”¹ä¸ºå‰ç½®æ˜¾ç¤º
                // ç²¾ç¡®è®©çª—å£è´´è¿‘å±å¹•åº•éƒ¨
                if let screenFrame = NSScreen.main?.visibleFrame {
                    let windowHeight: CGFloat = 450
                    let windowY = screenFrame.minY + 25
                    let windowX = (screenFrame.width - 450) / 2
                    selectorWindow?.setFrame(
                        NSRect(
                            x: windowX,
                            y: windowY,
                            width: 450,
                            height: windowHeight
                        ),
                        display: false
                    )
                }
                selectorWindow?.isMovableByWindowBackground = true
            }
            // ç¡®ä¿æ˜¾ç¤ºçª—å£
            selectorWindow?.makeKeyAndOrderFront(nil)

            // ç¡®ä¿æ¿€æ´»åº”ç”¨å¹¶å°†çª—å£ç½®é¡¶
            NSApp.activate(ignoringOtherApps: true)
        } else {
            selectorWindow?.orderOut(nil)
        }
    }
    var body: some Scene {
        MenuBarExtra(
            content: {
                Toggle(
                    String(
                        format: "%d Bit  %.1f kHz",
                        audioManager.bitDepth ?? 0,
                        Double(audioManager.sampleRate ?? 0) / 1000.0
                    ),
                    isOn: $isAudioSwitch
                )
                Divider()
                Toggle("æ˜¾ç¤ºæ­Œè¯", isOn: $isKaraokeVisible)
                //.keyboardShortcut("s")
                Divider()
                Toggle("å…¨å±æ­Œè¯", isOn: $isFullScreenVisible)
                //.keyboardShortcut("f")

                //                Divider()
                //
                //                Button("ç›¸ä¼¼æ­Œæ›²", action: appDelegate.similarSongTapped)

                Divider()
                Button("ç›¸ä¼¼æ­Œæ‰‹") {
                    showSimilarArtistWindow()
                }

                Divider()
                Button("åˆ é™¤æœ¬åœ°ç¼“å­˜", action: appDelegate.delCurrentSongObject)
                //.keyboardShortcut("d")
                Divider()
                Button("å‰ªè´´æ¿è¯»å–åŸå§‹æ­Œæ›²å", action: appDelegate.manualNamefetch)

                Divider()
                Button("é€€å‡º") {
                    NSApplication.shared.terminate(nil)
                }
                .keyboardShortcut("q")
            },
            label: {
                Group {
                    Image(systemName: "headphones.circle")
                }
                .onAppear {
                    viewModel.isViewLyricsShow =
                        isKaraokeVisible || isFullScreenVisible
                    CreateKaraoke()
                    viewModel.enableAudioSync = isAudioSwitch
                }
                .onReceive(viewModel.$needNanualSelection) { newValue in
                    createLyricsManualView(needNanualSelection: newValue)
                }
            }
        )
        .onChange(
            of: isFullScreenVisible,
            {
                Log.ui.info(
                    "isFullScreenVisible change: \(isFullScreenVisible)"
                )
                viewModel.isViewLyricsShow =
                    isKaraokeVisible || isFullScreenVisible
                if isFullScreenVisible {
                    openWindow(id: "fullScreen")
                    NSApplication.shared.activate()
                }
                // å…¨å±æ—¶å»æ‰å¡æ‹‰OKæ˜¾ç¤º
                CreateKaraoke()
            }
        )
        .onChange(
            of: isKaraokeVisible,
            {
                Log.ui.info("isKaraokeVisible change: \(isKaraokeVisible)")
                viewModel.isViewLyricsShow =
                    isKaraokeVisible || isFullScreenVisible
                CreateKaraoke()
            }
        )
        .onChange(of: isAudioSwitch) {
            viewModel.enableAudioSync = isAudioSwitch
        }
        .onChange(
            of: viewModel.isLyricsPlaying,
            {
                CreateKaraoke()
            }
        )
        WindowGroup("fullScreenLyrics", id: "fullScreen") {
            FullScreenView(isPresented: $isFullScreenVisible).environmentObject(
                viewModel
            )
            .onWindowDidAppear { window in
                window.collectionBehavior = .fullScreenPrimary

                // é˜»æ­¢ ESC
                NSEvent.addLocalMonitorForEvents(matching: .keyDown) {
                    event in
                    if event.keyCode == 53 { return nil }  // Esc
                    return event
                }

                // è®¾ç½®é€€å‡ºå…¨å±æ—¶å…³é—­çª—å£
                let delegate = FullScreenWindowDelegate()
                delegate.onExitFullScreen = {
                    isFullScreenVisible = false
                    window.close()
                }
                window.delegate = delegate

                // å°† delegate é™„ç€åˆ° window ä¸Šï¼Œé¿å…é‡Šæ”¾
                objc_setAssociatedObject(
                    window,
                    "FullScreenDelegateKey",
                    delegate,
                    .OBJC_ASSOCIATION_RETAIN_NONATOMIC
                )

                // åˆ‡æ¢åˆ°å…¨å±
                if !window.styleMask.contains(.fullScreen) {
                    window.toggleFullScreen(nil)
                }
            }
            .onDisappear {
                isFullScreenVisible = false
            }
        }
    }
}
extension View {
    func onWindowDidAppear(_ perform: @escaping (NSWindow) -> Void) -> some View
    {
        background(WindowFinder(onWindow: perform))
    }
}
struct WindowFinder: NSViewRepresentable {
    let onWindow: (NSWindow) -> Void

    func makeNSView(context: Context) -> NSView {
        let nsView = NSView()
        DispatchQueue.main.async {
            if let window = nsView.window {
                onWindow(window)
            }
        }
        return nsView
    }

    func updateNSView(_ nsView: NSView, context: Context) {}
}

// NSWindowDelegate å®ç°ï¼Œå¤„ç†é€€å‡ºå…¨å±
class FullScreenWindowDelegate: NSObject, NSWindowDelegate {
    var onExitFullScreen: (() -> Void)?

    func windowDidExitFullScreen(_ notification: Notification) {
        // å»¶è¿Ÿå…³é—­ï¼Œç­‰ç³»ç»Ÿå®Œæˆé€€å‡ºåŠ¨ç”»
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
            self.onExitFullScreen?()
        }
    }
}


// ===============================
// FILE: ./AudioSync/LyricsParser/Extensions.swift
// ===============================
//
//  Extensions.swift
//  SpotlightLyrics
//
//  Created by Scott Rong on 2017/7/28.
//  Copyright Â© 2017 Scott Rong. All rights reserved.
//

import Foundation

extension CharacterSet {
    public static let quotes = CharacterSet(charactersIn: "\"'")
}

extension String {
    public func emptyToNil() -> String? {
        return self == "" ? nil : self
    }
    
    public func blankToNil() -> String? {
        return self.trimmingCharacters(in: .whitespacesAndNewlines) == "" ? nil : self
    }
}


// ===============================
// FILE: ./AudioSync/LyricsParser/LyricsHeader.swift
// ===============================
//
//  LyricsHeader.swift
//  SpotlightLyrics
//
//  Created by Scott Rong on 2017/7/28.
//  Copyright Â© 2017 Scott Rong. All rights reserved.
//

import Foundation

public struct LyricsHeader {
    // ti
    public var title: String?
    // ar
    public var author: String?
    // al
    public var album: String?
    // by
    public var by: String?
    // offset
    public var offset: TimeInterval = 0
    // re
    public var editor: String?
    // ve
    public var version: String?
}


// ===============================
// FILE: ./AudioSync/LyricsParser/LyricsParser.swift
// ===============================
//
//  LyricsParser.swift
//  SpotlightLyrics
//
//  Created by Scott Rong on 2017/4/2.
//  Copyright Â© 2017 Scott Rong. All rights reserved.
//

import Foundation
import Regex

public enum LyricsFormat: Sendable {
    case netEase  // åŸå§‹ LRC æ ¼å¼
    case qq  // QQ æ­Œè¯æ ¼å¼
}

public class LyricsParser {

    let lyricsLineRegex = Regex(
        #"^(\[[+-]?\d+:\d+(?:\.\d+)?\])+(?!\[)([^ã€\n\r]*)(?:ã€(.*)ã€‘)?"#,
        options: .anchorsMatchLines)

    public var header: LyricsHeader
    public private(set) var lyrics: [LyricLine] = []

    // MARK: Initializers

    public init(lyrics: String, format: LyricsFormat) {
        header = LyricsHeader()
        switch format {
        case .netEase:
            commonInit(lyrics: lyrics)
        case .qq:
            QQLyricInit(lyrics)
        }
    }

    private func commonInit(lyrics: String) {
        header = LyricsHeader()
        parse(lyrics: lyrics)
    }

    // MARK: Privates

    private func parse(lyrics: String) {
        let lines =
            lyrics
            .replacingOccurrences(of: "\\n", with: "\n")
            .trimmingCharacters(in: .quotes)
            .trimmingCharacters(in: .newlines)
            .components(separatedBy: .newlines)

        for line in lines {
            parseLine(line: line)
        }

        // sort by time
        self.lyrics.sort { $0.startTimeMS < $1.startTimeMS }
    }

    private func parseLine(line: String) {
        guard let line = line.blankToNil() else {
            return
        }

        //        if let title = parseHeader(prefix: "ti", line: line) {
        //            header.title = title
        //            return
        //        }
        //        if let author = parseHeader(prefix: "ar", line: line) {
        //            header.author = author
        //            return
        //        }
        //        if let album = parseHeader(prefix: "al", line: line) {
        //            header.album = album
        //            return
        //        }
        //        if let by = parseHeader(prefix: "by", line: line) {
        //            header.by = by
        //            return
        //        }
        if let offset = parseHeader(prefix: "offset", line: line) {
            header.offset = TimeInterval(offset) ?? 0
            return
        }
        if !line.hasSuffix("]") {
            lyrics += parseLyric(line: line)
        }
        //        if let editor = parseHeader(prefix: "re", line: line) {
        //            header.editor = editor
        //            return
        //        }
        //        if let version = parseHeader(prefix: "ve", line: line) {
        //            header.version = version
        //            return
        //        }

    }

    private func parseHeader(prefix: String, line: String) -> String? {
        if line.hasPrefix("[" + prefix + ":") && line.hasSuffix("]") {
            let startIndex = line.index(
                line.startIndex, offsetBy: prefix.count + 2)
            let endIndex = line.index(line.endIndex, offsetBy: -1)
            return String(line[startIndex..<endIndex])
        } else {
            return nil
        }
    }

    private func parseLyric(line: String) -> [LyricLine] {
        var cLine = line
        var items: [LyricLine] = []
        while cLine.hasPrefix("[") {
            guard let closureIndex = cLine.range(of: "]")?.lowerBound else {
                break
            }

            let startIndex = cLine.index(cLine.startIndex, offsetBy: 1)
            let endIndex = cLine.index(closureIndex, offsetBy: -1)
            let amidString = String(cLine[startIndex..<endIndex])

            let amidStrings = amidString.components(separatedBy: ":")
            var hour: TimeInterval = 0
            var minute: TimeInterval = 0
            var second: TimeInterval = 0
            if amidStrings.count >= 1 {
                second = TimeInterval(amidStrings[amidStrings.count - 1]) ?? 0
            }
            if amidStrings.count >= 2 {
                minute = TimeInterval(amidStrings[amidStrings.count - 2]) ?? 0
            }
            if amidStrings.count >= 3 {
                hour = TimeInterval(amidStrings[amidStrings.count - 3]) ?? 0
            }
            cLine.removeSubrange(
                cLine.startIndex..<cLine.index(closureIndex, offsetBy: 1))
            cLine = cLine.trimmingCharacters(in: .whitespaces)
            // Create a LyricLine with the calculated start time and the remaining line as the words
            let lyricLine = LyricLine(
                startTime: 1000
                    * (hour * 3600 + minute * 60 + second + header.offset),
                words: cLine)
            items.append(lyricLine)
        }

        return items
    }

    func mergeLyrics(translation: LyricsParser, threshold: TimeInterval = 0.02)
        -> [LyricLine]
    {
        var merged: [LyricLine] = []
        var i = 0
        var j = 0

        let originalLines = self.lyrics
        let translationLines = translation.lyrics

        while i < originalLines.count && j < translationLines.count {
            let originalLine = originalLines[i]
            let translationLine = translationLines[j]
            let timeDiff = abs(
                originalLine.startTimeMS - translationLine.startTimeMS)

            if timeDiff < threshold {
                // æ—¶é—´æˆ³åŒ¹é…ï¼Œåˆå¹¶ç¿»è¯‘
                var mergedLine = originalLine
                mergedLine.attachments[.translation()] = .plainText(
                    translationLine.words)
                merged.append(mergedLine)
                i += 1
                j += 1
            } else if originalLine.startTimeMS < translationLine.startTimeMS {
                // åŸå§‹æ­Œè¯æ—¶é—´æˆ³è¾ƒæ—©ï¼Œæ·»åŠ åŸå§‹æ­Œè¯è¡Œ
                merged.append(originalLine)
                i += 1
            } else {
                // ç¿»è¯‘æ­Œè¯æ—¶é—´æˆ³è¾ƒæ—©ï¼Œè·³è¿‡ç¿»è¯‘è¡Œ
                j += 1
            }
        }

        // æ·»åŠ å‰©ä½™çš„åŸå§‹æ­Œè¯è¡Œ
        while i < originalLines.count {
            merged.append(originalLines[i])
            i += 1
        }

        return merged
    }

    private func QQLyricInit(_ description: String) {
        let lines = lyricsLineRegex.matches(in: description).flatMap { match in
            let timeTagStr = match[1]!.string
            let timeTags = resolveTimeTag(timeTagStr)

            let lyricsContentStr = match[2]!.string
            var line = LyricLine(startTime: 0, words: lyricsContentStr)

            if let translationStr = match[3]?.string, !translationStr.isEmpty {
                line.attachments[.translation()] = .plainText(translationStr)
            }

            return timeTags.map { timeTag in
                var l = line
                l.startTimeMS = timeTag * 1000
                return l
            }
        }.sorted {
            $0.startTimeMS < $1.startTimeMS
        }
        self.lyrics = lines
    }

    private func resolveTimeTag(_ str: String) -> [TimeInterval] {
        let timeTagRegex = Regex(#"\[([-+]?\d+):(\d+(?:\.\d+)?)\]"#)
        let matchs = timeTagRegex.matches(in: str)
        return matchs.map { match in
            let min = Double(match[1]!.content)!
            let sec = Double(match[2]!.content)!
            return min * 60 + sec
        }
    }
}


// ===============================
// FILE: ./AudioSync/model/Artist.swift
// ===============================
import AppKit
import Foundation
import SwiftData

struct Artist: Identifiable, Sendable, Encodable {
    var id: String
    var mbid: String
    var name: String
    var url: String
    var image: Data?

    init(name: String, url: String = "", mbid: String = "") {
        self.id = "artist:\(name)+\(url)"
        self.name = name
        self.url = url
        self.mbid = mbid
    }

}
struct ArtistFromLastFMResponse: Decodable, Encodable {
    let similarartists: Similarartists?

    struct Similarartists: Decodable, Encodable {
        let artist: [ArtistEntity]?

        struct ArtistEntity: Decodable, Encodable {
            let name: String
            let mbid: String?
            let url: String
        }
    }
}

struct SimilarSong: Identifiable, Sendable, Encodable {
    var id: String
    var name: String
    var mbid: String
    var artist: String
    init(name: String, mbid: String, artist: String = "") {
        self.id = "song:\(name)-\(artist)"
        self.name = name
        self.mbid = mbid
        self.artist = artist
    }

}
struct SongFromLastFMResponse: Decodable, Encodable {
    let similartracks: SongFromLastFMResponse.SimilarTrack?

    struct SimilarTrack: Decodable, Encodable {
        let track: [SimilarTrack.TrackEntity]
        struct TrackEntity: Decodable, Encodable {
            let name: String
            let mbid: String?
            let artist: TrackEntity.Artist
            struct Artist: Decodable, Encodable {
                let name: String
            }
        }
    }
}


// ===============================
// FILE: ./AudioSync/model/Caches.swift
// ===============================
import Foundation

actor CoverCache {
    private var cache: [String: CacheEntry] = [:]
    private var accessOrder: [String] = []  // LRU é˜Ÿåˆ—
    private let maxMemorySize: Int = 100 * 1024 * 1024  // 100MB
    private var currentSize: Int = 0

    struct CacheEntry {
        let data: Data
        let size: Int
    }

    func get(for key: String) -> Data? {
        guard let entry = cache[key] else { return nil }

        // æ›´æ–° LRUï¼ˆå°† key ç§»åˆ°é˜Ÿå°¾ï¼‰
        if let idx = accessOrder.firstIndex(of: key) {
            accessOrder.remove(at: idx)
        }
        accessOrder.append(key)

        return entry.data
    }

    func set(_ data: Data, for key: String) {
        let size = data.count

        // å¦‚æœå·²å­˜åœ¨åˆ™å…ˆç§»é™¤
        if let old = cache[key] {
            currentSize -= old.size
            cache.removeValue(forKey: key)
            accessOrder.removeAll(where: { $0 == key })
        }

        // æ’å…¥æ–°å€¼
        cache[key] = CacheEntry(data: data, size: size)
        accessOrder.append(key)
        currentSize += size

        // å†…å­˜è¶…å‡ºé™åˆ¶ -> é€ä¸ªæ·˜æ±° LRU
        trimIfNeeded()
    }

    private func trimIfNeeded() {
        while currentSize > maxMemorySize, let oldestKey = accessOrder.first {
            if let entry = cache[oldestKey] {
                currentSize -= entry.size
            }
            cache.removeValue(forKey: oldestKey)
            accessOrder.removeFirst()
        }
    }
}
actor NetWorkQueue {
    private var queue: [String] = []

    func contains(_ key: String) -> Bool {
        return queue.contains(key)
    }

    func append(_ key: String) {
        queue.append(key)
    }
    func remove(_ key: String) {
        if let index = queue.firstIndex(of: key) {
            queue.remove(at: index)
        }
    }
}

actor ItunesSongCache {
    private var cache: [String: SongSearchResult.Song] = [:]
    private var ongoingTasks: [String: Task<SongSearchResult.Song, Error>] = [:]
    private var keysOrder: [String] = []
    private let maxSize: Int
    init(maxSize: Int = 30) {
        self.maxSize = maxSize
    }
    func get(for key: String) -> SongSearchResult.Song? {
        return cache[key]
    }

    func set(_ song: SongSearchResult.Song, for key: String) {
        if cache[key] == nil {
            keysOrder.append(key)
        }
        cache[key] = song
        ongoingTasks[key] = nil
        enforceLimit()
    }
    private func enforceLimit() {
        while keysOrder.count > maxSize {
            let oldestKey = keysOrder.removeFirst()
            cache[oldestKey] = nil
        }
    }
    func task(for key: String) -> Task<SongSearchResult.Song, Error>? {
        return ongoingTasks[key]
    }

    func setTask(_ task: Task<SongSearchResult.Song, Error>, for key: String) {
        ongoingTasks[key] = task
    }
    func removeTask(for key: String) {
        ongoingTasks[key] = nil
    }
}


// ===============================
// FILE: ./AudioSync/model/Key.swift
// ===============================
// API Key
import Foundation

struct Key {
    static let siliconFlow: String =
        "sk-sgcoykpiuvezprgkqdkccxwlmxyhbixkfgfvvdffovsuoemx"
    static let lastfm: String = "7c53dde26c531f5d311fd23734b54150"
}


// ===============================
// FILE: ./AudioSync/model/LyricStruct.swift
// ===============================
import Foundation


public struct LyricLine: Decodable, Hashable, Encodable, Equatable {
    public var startTimeMS: TimeInterval
    public let words: String
    public var attachments: Attachments
    public let id = UUID()

    enum CodingKeys: String, CodingKey {
        case startTimeMS = "startTimeMs"
        case words
        case attachments
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        do {
            self.startTimeMS = try container.decode(
                TimeInterval.self, forKey: .startTimeMS)
        } catch {
            let str = try container.decode(String.self, forKey: .startTimeMS)
            self.startTimeMS = TimeInterval(str) ?? 0
        }
        self.words = try container.decode(String.self, forKey: .words)
        self.attachments =
            try container.decodeIfPresent(
                Attachments.self, forKey: .attachments) ?? Attachments()
    }

    init(
        startTime: TimeInterval, words: String,
        attachments: Attachments = Attachments()
    ) {
        self.startTimeMS = startTime
        self.words = words
        self.attachments = attachments
    }
}

struct NetEaseSearch: Decodable {
    let result: Result

    struct Result: Decodable {
        let songs: [Song]

        struct Song: Decodable {
            let name: String
            let id: Int
            let duration: Int?  // milliseconds
            let al: Album
            let ar: [Artist]
        }

        struct Album: Decodable {
            let id: Int
            let name: String
            let picUrl: String
        }

        struct Artist: Decodable {
            let name: String
        }
    }
}
struct NetEaseArtist: Decodable{
    let result: NetEaseArtist.Result
    
    struct Result: Decodable {
        let artists: [NetEaseArtist.Artist]
    }
    struct Artist: Decodable {
        let name: String
        let picUrl: String
        let id: Int
    }
}

struct NetEaseLyrics: Decodable {
    let lrc: Lyric?
    let klyric: Lyric?
    let tlyric: Lyric?
    let lyricUser: User?
    let yrc: Lyric?
    /*
    let sgc: Bool
    let sfy: Bool
    let qfy: Bool
    let code: Int
    let transUser: User
     */

    struct User: Decodable {
        let nickname: String

        /*
        let id: Int
        let status: Int
        let demand: Int
        let userid: Int
        let uptime: Int
         */
    }

    struct Lyric: Decodable {
        let lyric: String?

        /*
        let version: Int
         */
    }
}
struct QQSearch: Decodable {
    let data: Data
    let code: Int

    struct Data: Decodable {
        let song: Song
        struct Song: Decodable {
            let list: [Item]
            struct Item: Decodable {
                let songmid: String
                let songname: String
                let albumname: String
                let albummid: String
                let albumid: Int?
                let singer: [Singer]
                let interval: Int?
                struct Pay: Decodable {
                    let payalbum: Int
                    let payalbumprice: Int
                    let paydownload: Int
                    let payinfo: Int
                    let payplay: Int
                    let paytrackmouth: Int
                    let paytrackprice: Int
                }
                struct Preview: Decodable {
                    let trybegin: Int
                    let tryend: Int
                    let trysize: Int
                }
                struct Singer: Decodable {
                    let name: String
                }
            }
        }
    }
}

struct QQLyrics: Decodable {
    let retcode: Int
    let code: Int
    let subcode: Int
    let lyric: Data
    let trans: Data?
}
struct QQAlbum: Decodable, Encodable{
    let code: Int
    let data:Album
    struct Album: Decodable, Encodable {
        let album_id:String?
        let album_mid: String
        let album_name: String?
        let headpiclist: [Headpiclist]
        struct Headpiclist: Decodable, Encodable{
            let picurl: String
        }
    }
}
extension QQLyrics {

    var lyricString: String? {
        return String(data: lyric, encoding: .utf8)?.decodingXMLEntities()
    }

    var transString: String? {
        guard let data = trans,
            let string = String(data: data, encoding: .utf8)
        else {
            return nil
        }
        return string.decodingXMLEntities()
    }
}

struct OriginalName: Decodable, Encodable {
    let trackName: String
    let artist: String
    let album: String
}

public struct Attachments: Codable, Hashable {
    var content: [Tag: LyricsLineAttachment] = [:]

    subscript(tag: Tag) -> LyricsLineAttachment? {
        get { content[tag] }
        set { content[tag] = newValue }
    }

    enum Tag: String, Codable, Hashable {
        case translation = "tr"

        static func translation() -> Tag { .translation }
    }
}

enum LyricsLineAttachment: Codable, Hashable {
    case plainText(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let text = try container.decode(String.self)
        self = .plainText(text)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .plainText(let str):
            try container.encode(str)
        }
    }

}
extension LyricsLineAttachment {
    var stringValue: String? {
        if case let .plainText(str) = self {
            return str
        }
        return nil
    }
}

extension String {

    private static let xmlEntities: [Substring: Character] = [
        "&quot;": "\"",
        "&amp;": "&",
        "&apos;": "'",
        "&lt;": "<",
        "&gt;": ">",
    ]

    func decodingXMLEntities() -> String {

        // ===== Utility functions =====

        // Convert the number in the string to the corresponding
        // Unicode character, e.g.
        //    decodeNumeric("64", 10)   --> "@"
        //    decodeNumeric("20ac", 16) --> "â‚¬"
        func decodeNumeric(_ string: Substring, base: Int) -> Character? {
            guard let code = UInt32(string, radix: base),
                let uniScalar = UnicodeScalar(code)
            else { return nil }
            return Character(uniScalar)
        }

        // Decode the HTML character entity to the corresponding
        // Unicode character, return `nil` for invalid input.
        //     decode("&#64;")    --> "@"
        //     decode("&#x20ac;") --> "â‚¬"
        //     decode("&lt;")     --> "<"
        //     decode("&foo;")    --> nil
        func decode(_ entity: Substring) -> Character? {

            if entity.hasPrefix("&#x") || entity.hasPrefix("&#X") {
                return decodeNumeric(entity.dropFirst(3).dropLast(), base: 16)
            } else if entity.hasPrefix("&#") {
                return decodeNumeric(entity.dropFirst(2).dropLast(), base: 10)
            } else {
                return String.xmlEntities[entity]
            }
        }

        // ===== Method starts here =====

        var result = ""
        var position = startIndex

        // Find the next '&' and copy the characters preceding it to `result`:
        while let ampRange = self[position...].range(of: "&") {
            result.append(contentsOf: self[position..<ampRange.lowerBound])
            position = ampRange.lowerBound

            // Find the next ';' and copy everything from '&' to ';' into `entity`
            guard let semiRange = self[position...].range(of: ";") else {
                // No matching ';'.
                break
            }
            let entity = self[position..<semiRange.upperBound]
            position = semiRange.upperBound

            if let decoded = decode(entity) {
                // Replace by decoded character:
                result.append(decoded)
            } else {
                // Invalid entity, copy verbatim:
                result.append(contentsOf: entity)
            }
        }
        // Copy remaining characters to `result`:
        result.append(contentsOf: self[position...])
        return result
    }
}


// ===============================
// FILE: ./AudioSync/model/Song.swift
// ===============================
import SwiftData
import Foundation

@Model
final class Song {
    @Attribute(.unique) var id: String
    var trackName: String
    var lyricsData: Data?

    // è‡ªå®šä¹‰å±æ€§ï¼ˆä¸å­˜å‚¨ï¼Œåªæ˜¯æ˜ å°„ï¼‰
    var lyrics: [LyricLine] {
        get {
            guard let data = lyricsData else { return [] }
            return (try? JSONDecoder().decode([LyricLine].self, from: data)) ?? []
        }
        set {
            lyricsData = try? JSONEncoder().encode(newValue)
        }
    }

    init(id: String, trackName: String, lyrics: [LyricLine]) {
        self.id = id
        self.trackName = trackName
        self.lyricsData = try? JSONEncoder().encode(lyrics)
    }

    func setLyrics(_ lines: [LyricLine]) {
        lyrics = lines
    }

    func getLyrics() -> [LyricLine] {
        lyrics
    }
}


// ===============================
// FILE: ./AudioSync/model/ViewModel.swift
// ===============================
import AppKit
import Combine
//
//  ViewModel.swift
//  AudioSync
//
//  Created by solo on 5/12/25.
//
import Foundation
import ScriptingBridge
import SwiftUI

@MainActor
class ViewModel: ObservableObject {

    static let shared: ViewModel = ViewModel()
    @Published var currentlyPlayingLyrics: [LyricLine] = []
    @Published var currentlyPlayingLyricsIndex: Int?
    @Published var karaokeFont: NSFont = NSFont.boldSystemFont(ofSize: 30)
    @Published var translationExists: Bool = true
    @Published var karaokeShowMultilingual: Bool = true
    @Published var isViewLyricsShow: Bool = false
    @Published var isLyricsPlaying: Bool = false
    @Published var allCandidates: [CandidateSong] = []
    @Published var needNanualSelection: Bool = false
    @Published var currentTrack: TrackInfo?
    @Published var scrollProxy: ScrollViewProxy?
    @Published var isCurrentTrackPlaying: Bool = false
    @Published var similarArtists: [Artist] = []
    @Published var currentAlbum: String?
    @Published var currentSong: String?
    @Published var refreshSimilarArtist: Bool = false
    @Published var enableAudioSync: Bool = true
    @Published var finishSwitch: String?
    var onCandidateSelected: ((CandidateSong) -> Void)?  // â—ï¸ç­‰å¾…ç”¨çš„å›è°ƒ

    lazy var appleMusicScript: MusicApplication? = SBApplication(
        bundleIdentifier: "com.apple.Music"
    )
    private var currentLyricsUpdaterTask: Task<Void, Error>?

    private var cancellables = Set<AnyCancellable>()

    private func lyricUpdater() async throws {
        repeat {
            Log.general.debug(
                "lyric index: \(String(describing: self.currentlyPlayingLyricsIndex))"
            )
            guard let script = self.appleMusicScript else {
                Log.general.info("no script")
                // pauses the timer bc there's no player position
                stopLyricUpdater()
                return
            }
            guard let playerPosition = script.playerPosition else {
                Log.general.info("no player position hence stopped")
                // pauses the timer bc there's no player position
                stopLyricUpdater()
                return
            }
            Log.general.debug("script player position: \(playerPosition)")
            // add a 700 (milisecond?) delay to offset the delta between spotify lyrics and apple music songs (or maybe the way apple music delivers playback position)
            // No need for Spotify Connect delay or fullscreen, this is APPLE MUSIC
            let currentTime = playerPosition * 1000 + 400
            guard let lastIndex: Int = upcomingIndex(currentTime) else {
                stopLyricUpdater()
                return
            }
            // If there is no current index (perhaps lyric updater started late and we're mid-way of the first lyric, or the user scrubbed and our index is expired)
            // Then we set the current index to the one before our anticipated index
            if currentlyPlayingLyricsIndex == nil && lastIndex > 0 {
                withAnimation(.linear(duration: 0.2)) {
                    currentlyPlayingLyricsIndex = lastIndex - 1
                }
            }

            let nextTimestamp = currentlyPlayingLyrics[lastIndex].startTimeMS
            let diff = nextTimestamp - currentTime
            Log.general.debug(
                "current time: \(currentTime). next time: \(nextTimestamp). the difference is \(diff)"
            )
            try await Task.sleep(nanoseconds: UInt64(1_000_000 * diff))
            Log.general.debug("last index: \(lastIndex)")
            if currentlyPlayingLyrics.count > lastIndex {
                withAnimation(.linear(duration: 0.2)) {
                    currentlyPlayingLyricsIndex = lastIndex
                }
            } else {
                currentlyPlayingLyricsIndex = nil
            }
            Log.general.info(
                "current lyrics index is now \(String(describing: self.currentlyPlayingLyricsIndex))"
            )
        } while !Task.isCancelled
    }

    func startLyricUpdater() {
        Log.general.debug("start update task")
        Log.general.debug(
            "isViewLyricsShow: \(self.isViewLyricsShow), lyrics.isEmpty: \(self.currentlyPlayingLyrics.isEmpty)"
        )
        currentLyricsUpdaterTask?.cancel()
        currentLyricsUpdaterTask = Task {
            do {
                try await lyricUpdater()
            } catch {
                Log.general.info("lyric updater were canceled \(error)")
            }
        }
    }

    func stopLyricUpdater() {
        Log.general.debug("stop lyric updater")
        currentLyricsUpdaterTask?.cancel()
    }

    func upcomingIndex(_ currentTime: Double) -> Int? {
        if let currentlyPlayingLyricsIndex {
            let newIndex = currentlyPlayingLyricsIndex + 1
            if newIndex >= currentlyPlayingLyrics.count {
                Log.general.warning("âš ï¸ REACHED LAST LYRIC!!!!!!!!")
                // if current time is before our current index's start time, the user has scrubbed and rewinded
                // reset into linear search mode
                if currentTime
                    < currentlyPlayingLyrics[currentlyPlayingLyricsIndex]
                    .startTimeMS
                {
                    return currentlyPlayingLyrics.firstIndex(where: {
                        $0.startTimeMS > currentTime
                    })
                }
                return nil
            } else if currentTime
                > currentlyPlayingLyrics[currentlyPlayingLyricsIndex]
                .startTimeMS,
                currentTime < currentlyPlayingLyrics[newIndex].startTimeMS
            {
                Log.general.info("just the next lyric")
                return newIndex
            }
        }
        // linear search through the array to find the first lyric that's right after the current time
        // done on first lyric update for the song, as well as post-scrubbing
        return currentlyPlayingLyrics.firstIndex(where: {
            $0.startTimeMS > currentTime
        })
    }

}
extension NSImage {
    func toSwiftUIImage() -> Image {
        Image(nsImage: self)
    }
    func findDominantColors(maxK: Int = 3) -> [Color]? {
        guard let tiffData = self.tiffRepresentation,
            let bitmap = NSBitmapImageRep(data: tiffData),
            let cgImage = bitmap.cgImage
        else {
            return nil
        }

        let size = CGSize(width: 128, height: 128)
        guard
            let context = CGContext(
                data: nil,
                width: Int(size.width),
                height: Int(size.height),
                bitsPerComponent: 8,
                bytesPerRow: Int(size.width) * 4,
                space: CGColorSpaceCreateDeviceRGB(),
                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
            )
        else { return nil }

        context.draw(cgImage, in: CGRect(origin: .zero, size: size))
        guard let data = context.data else { return nil }
        let ptr = data.bindMemory(
            to: UInt8.self,
            capacity: Int(size.width * size.height * 4)
        )

        var points: [(CGFloat, CGFloat, CGFloat)] = []

        for x in 0..<Int(size.width) {
            for y in 0..<Int(size.height) {
                let offset = 4 * (y * Int(size.width) + x)
                let r = CGFloat(ptr[offset]) / 255.0
                let g = CGFloat(ptr[offset + 1]) / 255.0
                let b = CGFloat(ptr[offset + 2]) / 255.0
                let a = CGFloat(ptr[offset + 3]) / 255.0
                if a > 0.5 {
                    points.append((r, g, b))
                }
            }
        }

        // è‡ªåŠ¨ç¡®å®šèšç±»æ•° kï¼ˆä¸è¶…è¿‡ maxKï¼‰
        let k = min(maxK, max(1, Int(sqrt(Double(points.count)) / 2)))

        guard points.count >= k else { return nil }

        // ç®€æ˜“ k-means èšç±»
        var centroids = points.shuffled().prefix(k)
        var clusters: [[(CGFloat, CGFloat, CGFloat)]] = Array(
            repeating: [],
            count: k
        )

        for _ in 0..<10 {
            clusters = Array(repeating: [], count: k)
            for point in points {
                let index = centroids.enumerated().min(by: {
                    pow($0.1.0 - point.0, 2) + pow($0.1.1 - point.1, 2)
                        + pow($0.1.2 - point.2, 2)
                        < pow($1.1.0 - point.0, 2) + pow($1.1.1 - point.1, 2)
                        + pow($1.1.2 - point.2, 2)
                })!.offset
                clusters[index].append(point)
            }

            for i in 0..<k {
                if clusters[i].isEmpty { continue }
                let sum = clusters[i].reduce((0.0, 0.0, 0.0)) {
                    ($0.0 + $1.0, $0.1 + $1.1, $0.2 + $1.2)
                }
                let count = CGFloat(clusters[i].count)
                centroids[i] = (sum.0 / count, sum.1 / count, sum.2 / count)
            }
        }

        // æ’åºå¹¶è¾“å‡ºé¢œè‰²
        let sorted = clusters.enumerated().sorted {
            $0.element.count > $1.element.count
        }
        return sorted.map {
            let sum = $0.element.reduce((0.0, 0.0, 0.0)) {
                ($0.0 + $1.0, $0.1 + $1.1, $0.2 + $1.2)
            }
            let count = CGFloat($0.element.count)
            return Color(
                red: sum.0 / count,
                green: sum.1 / count,
                blue: sum.2 / count
            )
        }
    }

}
struct CandidateSong: Sendable {
    let id: String
    let name: String
    let artist: String
    let album: String
    var albumId: String
    var albumCover: String
    let source: LyricsFormat
}


// ===============================
// FILE: ./AudioSync/service/AppDelegate.swift
// ===============================
//
//  ContentView.swift
//  AudioSync
//
//  Created by solo on 4/29/25.
//

import AppKit
import Cocoa
import Combine
import CoreAudio
import Foundation
import MusicKit
import SwiftData
import SwiftUI
import UserNotifications

class AppDelegate: NSObject, NSApplicationDelegate,
    UNUserNotificationCenterDelegate
{
    var statusBarItem: NSStatusItem!
    var audioManager = AudioFormatManager.shared
    var playbackNotifier: PlaybackNotifier?
    var networkUtil: NetworkUtil?
    @ObservedObject var viewModel: ViewModel = ViewModel.shared
    private var cancellables = Set<AnyCancellable>()
    var modelContainer: ModelContainer?
    private var networkQueue = NetWorkQueue()

    func applicationDidFinishLaunching(_ notification: Notification) {

        NSApp.setActivationPolicy(.accessory)

        UNUserNotificationCenter.current().delegate = self
        Task { @MainActor in
            playbackNotifier = PlaybackNotifier(viewModel: self.viewModel)
            networkUtil = NetworkUtil(viewModel: self.viewModel)

            self.playbackNotifier?.onPlay = {
                [weak self] trackInfo, trigger in
                Log.backend.debug("playbackNotifier.onPlay \(trigger)")
                guard let self = self else {
                    return
                }
                // é‡‡æ ·ç‡å’Œä½æ·±åŒæ­¥
                if trigger == .formatSwitch {
                    await withCheckedContinuation { continuation in
                        var didResume = false
                        Task {
                            self.audioManager.onFormatUpdate = {
                                sampleRate,
                                bitDepth in
                                self.audioManager.updateOutputFormat()
                                if !didResume {
                                    didResume = true
                                    continuation.resume()
                                }
                            }
                            self.audioManager.startMonitoring()
                            DispatchQueue.main.asyncAfter(
                                deadline: .now() + 5.0
                            ) {
                                if !didResume {
                                    didResume = true
                                    continuation.resume()
                                }
                                self.audioManager.stopMonitoring()
                            }

                        }
                    }
                }
                // æ­Œè¯
                if trigger == .lyrics {
                    Task { [weak self] in
                        guard let self else { return }

                        viewModel.isLyricsPlaying = false
                        if viewModel.isCurrentTrackPlaying
                            && viewModel.isViewLyricsShow
                        {
                            if loadLyricsFromLocal() {
                                return
                            }

                            await loadLyricsFromNetwork()
                        }

                    }
                }
            }

            viewModel.$refreshSimilarArtist
                .removeDuplicates()
                .sink { [weak self] refreshSimilarArtist in
                    guard let self = self else { return }
                    if refreshSimilarArtist {
                        networkUtil?.fetchSimilarArtistsAndCovers()
                        viewModel.refreshSimilarArtist = false
                    }

                }
                .store(in: &cancellables)

            viewModel.$isViewLyricsShow
                .removeDuplicates()
                .sink { [weak self] isShowLyrics in
                    guard let self = self else { return }
                    Log.general.debug("æ˜¾ç¤ºæ­Œè¯ -> \(isShowLyrics)")
                    if isShowLyrics {
                        Task {
                            if let onPlay = self.playbackNotifier?.onPlay {
                                await onPlay(nil, .lyrics)
                            }
                        }
                    } else {
                        viewModel.stopLyricUpdater()
                    }
                }
                .store(in: &cancellables)

            viewModel.$isLyricsPlaying
                .removeDuplicates()
                .sink { [weak self] isLyricsPlaying in
                    guard let self = self else { return }
                    Log.general.debug("isLyricsPlaying -> \(isLyricsPlaying)")
                    if isLyricsPlaying {
                        viewModel.startLyricUpdater()
                    } else {
                        viewModel.stopLyricUpdater()
                        viewModel.currentlyPlayingLyricsIndex = nil
                    }
                }
                .store(in: &cancellables)

        }
        Task {
            let _ = await MusicKit.MusicAuthorization.request()

            do {
                try await UNUserNotificationCenter.current()
                    .requestAuthorization(options: [.alert, .sound, .badge])
            } catch {
                Log.backend.error("ç”¨æˆ·æ‹’ç»äº†é€šçŸ¥æƒé™")
            }
            // å‡ºå‘å¯åŠ¨æ—¶æ­Œè¯æ˜¾ç¤º
            if let onPlay = self.playbackNotifier?.onPlay {
                await onPlay(nil, .lyrics)
            }

        }

    }
    private func loadLyricsFromLocal() -> Bool {
        guard let modelContext = modelContainer?.mainContext else {
            return false
        }
        guard let trackID = viewModel.currentTrack?.trackID else {
            return false
        }
        let descriptor = FetchDescriptor<Song>(
            predicate: #Predicate { $0.id == trackID }
        )

        if let song = try? modelContext.fetch(descriptor).first {
            let localLyrics = song.getLyrics()
            if !localLyrics.isEmpty {
                Log.general.debug("æœ¬åœ°æ­Œè¯")
                viewModel.currentlyPlayingLyrics = localLyrics
                viewModel.isLyricsPlaying = true
                return true
            }
        }
        return false
    }

    private func loadLyricsFromNetwork() async {
        guard let trackInfo = viewModel.currentTrack else {
            return
        }
        let trackName = trackInfo.name
        let artist = trackInfo.artist
        let queueKey = "\(trackName)-\(artist)"

        do {
            if await networkQueue.contains(queueKey) {
                return
            }
            await networkQueue.append(queueKey)
            guard !trackName.isEmpty, !artist.isEmpty else {
                Log.general.warning("âš ï¸ åŸå§‹æ ‡é¢˜æˆ–è‰ºæœ¯å®¶ä¸ºç©ºï¼Œè·³è¿‡æ­Œè¯è¯·æ±‚")
                return
            }

            if let lyrics = try await networkUtil?.fetchLyrics(
                trackName: trackName,
                artist: artist,
                trackID: trackInfo.trackID,
                album: trackInfo.album,
                genre: trackInfo.genre
            ), !lyrics.isEmpty {
                let finishLyrics = finishLyric(lyrics)
                Log.general.debug("ç½‘ç»œæ­Œè¯")

                viewModel.currentlyPlayingLyrics = finishLyrics
                viewModel.isLyricsPlaying = true

                // song ä¿å­˜
                guard let modelContext = modelContainer?.mainContext else {
                    return
                }
                let song = Song(
                    id: trackInfo.trackID,
                    trackName: trackName,
                    lyrics: finishLyrics
                )
                modelContext.insert(song)
                try? modelContext.save()
                await networkQueue.remove(queueKey)
            }

        } catch {
            Log.general.error("ç½‘ç»œæ­Œè¯è·å–å¤±è´¥: \(error)")
            Log.notice.notice(
                "ç½‘ç»œæ­Œè¯è·å–å¤±è´¥",
                error.localizedDescription
            )
            await networkQueue.remove(queueKey)
        }
    }

    func finishLyric(_ rawLyrics: [LyricLine]) -> [LyricLine] {
        guard let last = rawLyrics.last else { return rawLyrics }
        let virtualEndLine = LyricLine(
            startTime: last.startTimeMS + 5000,
            words: ""
        )
        return rawLyrics + [virtualEndLine]
    }

    @objc func delCurrentSongObject() {
        guard let trackID = viewModel.currentTrack?.trackID
        else {
            return
        }
        viewModel.isLyricsPlaying = false
        // åˆ é™¤song
        let modelContext = modelContainer?.mainContext
        let descriptor = FetchDescriptor<Song>(
            predicate: #Predicate { $0.id == trackID }
        )
        if let song = try? modelContext?.fetch(descriptor).first {
            modelContext?.delete(song)
            try? modelContext?.save()
        }

        Task {
            if let onPlay = playbackNotifier?.onPlay {
                await onPlay(nil, .lyrics)
            }
        }
    }

    @objc func manualNamefetch() {
        Task {
            await manulNameAsyncFetch()
        }
    }

    private func manulNameAsyncFetch() async {
        do {
            guard
                let manualName = NSPasteboard.general.string(forType: .string),
                !manualName.trimmingCharacters(in: .whitespacesAndNewlines)
                    .isEmpty
            else {
                Log.general.warning("âš ï¸ ç²˜è´´æ¿ä¸­æ²¡æœ‰å­—ç¬¦ä¸²å†…å®¹")
                Log.notice.notice(
                    "ç©ºæ­Œæ›²å",
                    "âš ï¸ ç²˜è´´æ¿ä¸­æ²¡æœ‰å­—ç¬¦ä¸²å†…å®¹"
                )
                return
            }
            Log.general.debug("æ¥è‡ªç²˜è´´æ¿çš„æ­Œæ›²: \(manualName)")
            guard let currentTrack = viewModel.currentTrack else {
                return
            }
            viewModel.isLyricsPlaying = false
            let netEaseLyrics = try await networkUtil?.fetchLyrics(
                trackName: manualName,
                artist: currentTrack.artist,
                trackID: currentTrack.trackID,
                album: currentTrack.album,
                genre: currentTrack.genre
            )

            if !netEaseLyrics!.isEmpty {
                guard let modelContext = modelContainer?.mainContext else {
                    return
                }
                let finishLyrics = finishLyric(netEaseLyrics!)
                let trackID = currentTrack.trackID
                let descriptor = FetchDescriptor<Song>(
                    predicate: #Predicate { $0.id == trackID }
                )
                if let song = try? modelContext.fetch(descriptor).first {
                    modelContext.delete(song)
                }
                let songNew = Song(
                    id: currentTrack.trackID,
                    trackName: currentTrack.name,
                    lyrics: finishLyrics
                )
                modelContext.insert(songNew)

                try? modelContext.save()

                Task {
                    if let onPlay = playbackNotifier?.onPlay {
                        await onPlay(nil, .lyrics)
                    }
                }
            }

        } catch {
            Log.general.error("ç²˜è´´æ¿è·å–æ­Œè¯å¤±è´¥ï¼š\(error)")
        }
    }

    @objc func similarSongTapped() {
        guard let name = viewModel.currentTrack?.name,
            let artist = viewModel.currentTrack?.artist
        else {
            return
        }
        Task {
            let fetched = try? await networkUtil?.fetchSimilarSongs(
                name: name,
                artist: artist
            )
            Log.backend.debug("ç›¸ä¼¼æ­Œæ›²: \(JSON.stringify(fetched))")
            guard let script = viewModel.appleMusicScript else { return }

        }
    }
}

// ä¿®æ”¹åçš„AudioFormatManagerç±»

// ä¿æŒCore Audioç›¸å…³æ‰©å±•å’Œå·¥å…·æ–¹æ³•ä¸å˜
extension OSStatus {
    func toHexString() -> String {
        return String(format: "0x%08X", self)
    }
}
// 3. âœ… å®ç°ä»£ç†æ–¹æ³•ï¼Œå…è®¸å‰å°é€šçŸ¥
extension AppDelegate {
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler:
            @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        // å‘Šè¯‰ç³»ç»Ÿï¼šå³ä½¿åº”ç”¨åœ¨å‰å°ï¼Œä¹Ÿè¦æ˜¾ç¤º Banner å’Œå£°éŸ³
        // æ³¨æ„ï¼šmacOS 11.0+ ä½¿ç”¨ .bannerï¼Œæ—§ç‰ˆæœ¬å¯èƒ½ä½¿ç”¨ .alert
        if #available(macOS 11.0, *) {
            completionHandler([.banner, .sound])
        } else {
            completionHandler([.alert, .sound])
        }
    }
}


// ===============================
// FILE: ./AudioSync/service/AudioFormatManager.swift
// ===============================
import Combine
import CoreAudio

class AudioFormatManager: ObservableObject {
    @MainActor static let shared: AudioFormatManager = AudioFormatManager()
    @Published var sampleRate: Int?
    @Published var bitDepth: Int?

    private static let logRegex: NSRegularExpression? = {
        let pattern = #"(\d+) Hz.*?from (\d+)-bit source"#
        return try? NSRegularExpression(pattern: pattern)
    }()
    var needChange: Bool = true
    var currentFormat: (sampleRate: Int, bitDepth: Int) = (0, 0) {
        didSet {
            Log.backend.info("Format change from \(oldValue) to \(currentFormat)")
            // é¿å…ä¸å¿…è¦çš„æ›´æ–°ï¼Œå¦‚æœå€¼æ²¡æœ‰å®é™…å˜åŒ–
            if oldValue.sampleRate != currentFormat.sampleRate
                || oldValue.bitDepth != currentFormat.bitDepth
            {
                sampleRate = currentFormat.sampleRate
                bitDepth = currentFormat.bitDepth
                needChange = true
                onFormatUpdate?(
                    currentFormat.sampleRate,
                    currentFormat.bitDepth
                )
            } else {
                needChange = false
            }
        }
    }
    var onFormatUpdate: ((Int, Int) -> Void)?

    // ä¿æŒåŸæœ‰æ—¥å¿—ç›‘æ§å’Œæ ¼å¼è®¾ç½®é€»è¾‘...
    // [åŸæœ‰ä»£ç çš„ç§æœ‰å±æ€§å’Œæ–¹æ³•ä¿æŒä¸å˜]
    private var logProcess: Process?
    private var logPipe: Pipe?
    private var isMonitoring = false
    private let processingQueue = DispatchQueue(
        label: "com.audio.format.monitor",
        qos: .userInitiated
    )

    private var lastLogEntry: String = ""
    private var lastLogTime: TimeInterval = 0

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true
        Log.backend.info("start log monitoring")
        // å…ˆæŠ“è¿‡å» 1 ç§’çš„å†å²æ—¥å¿—ï¼Œé¿å…æ¼æ‰å¯åŠ¨å‰çš„ Input format
        fetchRecentLogs()

        setupLogProcess()
    }

    private func isDeviceRunning(_ deviceID: AudioDeviceID) -> Bool {
        var isRunning: UInt32 = 0
        var size = UInt32(MemoryLayout.size(ofValue: isRunning))
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyDeviceIsRunning,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )

        let status = AudioObjectGetPropertyData(
            deviceID,
            &address,
            0,
            nil,
            &size,
            &isRunning
        )

        return status == noErr && isRunning != 0
    }
    private func fetchRecentLogs() {
        // åœ¨åå°é˜Ÿåˆ—ä¸­æ‰§è¡Œï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
        processingQueue.async { [weak self] in
            let showProcess = Process()
            showProcess.executableURL = URL(fileURLWithPath: "/usr/bin/log")
            showProcess.arguments = [
                "show",
                "--style", "syslog",
                "--last", "1s",
                "--predicate",
                "process == 'Music' AND message CONTAINS 'ACAppleLosslessDecoder' AND message CONTAINS 'Input format' AND message CONTAINS 'source'",
                "--info",
            ]

            let pipe = Pipe()
            showProcess.standardOutput = pipe

            do {
                try showProcess.run()

                // åŒæ­¥è¯»å–æ‰€æœ‰è¾“å‡ºæ•°æ®ï¼Œç›´åˆ°è¿›ç¨‹ç»“æŸ
                let data = pipe.fileHandleForReading.readDataToEndOfFile()
                showProcess.waitUntilExit()  // ç¡®ä¿è¿›ç¨‹å·²å®Œå…¨ç»ˆæ­¢

                if let output = String(data: data, encoding: .utf8),
                    !output.isEmpty
                {
                    self?.parseLogOnBackground(output)
                }
            } catch {
                Log.backend.error(
                    "AudioFormatManager: fetchRecentLogs error: \(error)"
                )
            }
        }
    }
    private func setupLogProcess() {
        logProcess = Process()
        logProcess?.executableURL = URL(fileURLWithPath: "/usr/bin/log")
        logProcess?.arguments = [
            "stream",
            "--predicate",
            "process == 'Music' AND message CONTAINS 'ACAppleLosslessDecoder' AND message CONTAINS 'Input format' AND message CONTAINS 'source'",
            "--info",
        ]

        let pipe = Pipe()
        self.logPipe = pipe
        logProcess?.standardOutput = pipe

        // 2. âœ… ä¼˜åŒ–è¯»å–å¤„ç†é€»è¾‘
        pipe.fileHandleForReading.readabilityHandler = { [weak self] handle in
            // ä½¿ç”¨ autoreleasepool ç¡®ä¿æ¯æ¬¡è¯»å–çš„ä¸´æ—¶å˜é‡ç«‹å³é‡Šæ”¾
            autoreleasepool {
                let data = handle.availableData
                guard !data.isEmpty else { return }

                guard let output = String(data: data, encoding: .utf8) else {
                    return
                }

                // 3. âœ… åœ¨åå°çº¿ç¨‹ç›´æ¥è§£æï¼Œä¸è¦æ´¾å‘ç»™ MainActor
                self?.parseLogOnBackground(output)
            }
        }

        logProcess?.terminationHandler = { process in
            DispatchQueue.main.async {
                if AudioFormatManager.shared.isMonitoring == true {  // ä»…åœ¨ä»åœ¨ç›‘æ§çŠ¶æ€æ—¶é‡ç½®
                    AudioFormatManager.shared.isMonitoring = false
                }
            }
        }

        do {
            try logProcess?.run()
        } catch {
            Log.backend.error(
                "AudioFormatManager: setupLogProcess   error: \(error)"
            )
            DispatchQueue.main.async {
                AudioFormatManager.shared.isMonitoring = false  // å¯åŠ¨å¤±è´¥ï¼Œé‡ç½®çŠ¶æ€
            }
        }
    }
    private func parseLogOnBackground(_ log: String) {
        let now = Date().timeIntervalSince1970
        guard let regex = AudioFormatManager.logRegex else { return }

        let nsLog = log as NSString

        regex.enumerateMatches(
            in: log,
            range: NSRange(location: 0, length: nsLog.length)
        ) { match, _, _ in
            guard let match = match, match.numberOfRanges >= 3 else { return }

            let sampleRateStr = nsLog.substring(with: match.range(at: 1))
            let bitDepthStr = nsLog.substring(with: match.range(at: 2))

            if let sr = Int(sampleRateStr), let bd = Int(bitDepthStr) {
                // 5. âœ… è§£ææˆåŠŸåï¼Œå†æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼Œå‡å°‘ä¸»çº¿ç¨‹è´Ÿæ‹…
                if self.currentFormat.sampleRate == sr,
                    self.currentFormat.bitDepth == bd
                {
                    return
                }
                // åªæœ‰çœŸæ­£éœ€è¦æ›´æ–°æ—¶ï¼Œæ‰åˆ‡å›ä¸»çº¿ç¨‹
                Task { @MainActor in
                    AudioFormatManager.shared.currentFormat = (sr, bd)
                    AudioFormatManager.shared.stopMonitoring()
                }
            }
        }
    }

    func updateOutputFormat() {
        if !needChange {
            return
        }
        guard let deviceID = getDefaultOutputDevice(),
            deviceID != kAudioObjectUnknown
        else {
            return
        }

        setNominalSampleRate(currentFormat.sampleRate, for: deviceID)
        setStreamBitDepth(currentFormat.bitDepth, for: deviceID)
    }

    func stopMonitoring() {
        guard isMonitoring else { return }
        Log.backend.info("stop log monitoring")
        // 1. æ¸…ç†æµå¼ç›‘æ§çš„ handler
        logPipe?.fileHandleForReading.readabilityHandler = nil

        // 2. ç»ˆæ­¢æµå¼ç›‘æ§çš„è¿›ç¨‹
        if logProcess?.isRunning == true {
            logProcess?.terminate()
        }

        // 3. é‡Šæ”¾èµ„æºå¼•ç”¨
        logProcess = nil
        logPipe = nil

        DispatchQueue.main.async {
            AudioFormatManager.shared.isMonitoring = false
        }
    }

    deinit {
        // æ¸…ç† Process èµ„æº
        logProcess?.terminate()
        logProcess = nil
    }

    private func setNominalSampleRate(_ rate: Int, for device: AudioDeviceID) {

        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyNominalSampleRate,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )

        var sampleRate = Float64(rate)
        let status = AudioObjectSetPropertyData(
            device,
            &address,
            0,
            nil,
            UInt32(MemoryLayout.size(ofValue: sampleRate)),
            &sampleRate
        )

        if status != noErr {
            Log.backend.error("Sample rate set  \(status)")
        }
    }

    private func getDefaultOutputDevice() -> AudioDeviceID? {
        var deviceID: AudioDeviceID = kAudioObjectUnknown
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )

        var size = UInt32(MemoryLayout.size(ofValue: deviceID))
        guard
            AudioObjectGetPropertyData(
                AudioObjectID(kAudioObjectSystemObject),
                &address,
                0,
                nil,
                &size,
                &deviceID
            ) == noErr
        else {
            return nil
        }
        return deviceID
    }
    private func getDeviceName(_ deviceID: AudioDeviceID) -> String? {
        var name: CFString = "" as CFString
        var size = UInt32(MemoryLayout<CFString>.size)
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioObjectPropertyName,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )

        let status = AudioObjectGetPropertyData(
            deviceID,
            &address,
            0,
            nil,
            &size,
            &name
        )
        if status == noErr {
            return name as String
        } else {
            return nil
        }
    }
    private func setStreamBitDepth(_ depth: Int, for device: AudioDeviceID) {
        // å…ˆè·å–è®¾å¤‡çš„æ‰€æœ‰è¾“å‡ºæµ
        guard let streams = getOutputStreams(for: device) else {
            Log.backend.error("æ— æ³•è·å–è¾“å‡ºæµ")
            return
        }

        for stream in streams {
            // 1. è·å–è¯¥æµæ”¯æŒçš„ç‰©ç†æ ¼å¼
            guard let supportedFormats = getSupportedFormats(for: stream) else {
                continue
            }

            // 2. å¯»æ‰¾åŒ¹é…çš„æ ¼å¼
            let targetFormat = findMatchingFormat(
                supportedFormats,
                depth: depth,
                rate: currentFormat.sampleRate
            )

            // 3. è®¾ç½®ç‰©ç†æ ¼å¼
            var address = AudioObjectPropertyAddress(
                mSelector: kAudioStreamPropertyPhysicalFormat,
                mScope: kAudioObjectPropertyScopeGlobal,
                mElement: 0
            )

            var format = targetFormat.mFormat
            let status = AudioObjectSetPropertyData(
                stream,  // å…³é”®ä¿®æ”¹ï¼šåœ¨streamä¸Šè®¾ç½®è€Œä¸æ˜¯device
                &address,
                0,
                nil,
                UInt32(MemoryLayout<AudioStreamBasicDescription>.size),
                &format
            )

            if status == noErr {
                let deviceName =
                    getDeviceName(device) as NSString? ?? "Unknown Device"
                Log.backend.info(
                    "æˆåŠŸä¸ºã€Œ\(deviceName)ã€åŒæ­¥æ ¼å¼ï¼š\(format.mBitsPerChannel)bit/\(format.mSampleRate)Hz"
                )
            } else {
                Log.backend.error("è®¾ç½®å¤±è´¥ - \(status)")
            }
        }
    }

    // æ–°å¢æ–¹æ³•ï¼šè·å–è®¾å¤‡çš„æ‰€æœ‰è¾“å‡ºæµ
    private func getOutputStreams(for device: AudioDeviceID) -> [AudioStreamID]?
    {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreams,
            mScope: kAudioDevicePropertyScopeOutput,
            mElement: 0
        )

        var dataSize: UInt32 = 0
        guard
            AudioObjectGetPropertyDataSize(device, &address, 0, nil, &dataSize)
                == noErr
        else {
            return nil
        }

        let streamCount = Int(dataSize) / MemoryLayout<AudioStreamID>.size
        var streams = [AudioStreamID](repeating: 0, count: streamCount)
        guard
            AudioObjectGetPropertyData(
                device,
                &address,
                0,
                nil,
                &dataSize,
                &streams
            ) == noErr
        else {
            return nil
        }

        return streams
    }

    // æ–°å¢æ–¹æ³•ï¼šè·å–æµæ”¯æŒçš„ç‰©ç†æ ¼å¼
    private func getSupportedFormats(for stream: AudioStreamID)
        -> [AudioStreamRangedDescription]?
    {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioStreamPropertyAvailablePhysicalFormats,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: 0
        )

        var dataSize: UInt32 = 0
        guard
            AudioObjectGetPropertyDataSize(stream, &address, 0, nil, &dataSize)
                == noErr
        else {
            return nil
        }

        let formatCount =
            Int(dataSize) / MemoryLayout<AudioStreamRangedDescription>.size
        var formats = [AudioStreamRangedDescription](
            repeating: AudioStreamRangedDescription(),
            count: formatCount
        )
        guard
            AudioObjectGetPropertyData(
                stream,
                &address,
                0,
                nil,
                &dataSize,
                &formats
            ) == noErr
        else {
            return nil
        }

        return formats
    }

    // æ–°å¢æ–¹æ³•ï¼šå¯»æ‰¾åŒ¹é…çš„æ ¼å¼
    private func findMatchingFormat(
        _ formats: [AudioStreamRangedDescription],
        depth: Int,
        rate: Int
    ) -> AudioStreamRangedDescription {
        // ä¼˜å…ˆå¯»æ‰¾å®Œå…¨åŒ¹é…
        if let exactMatch = formats.first(where: {
            Int($0.mFormat.mSampleRate) == rate
                && $0.mFormat.mBitsPerChannel == UInt32(depth)
        }) {
            return exactMatch
        }
        let simplifiedFormats = formats.map { format in
            [
                "sampleRate": format.mFormat.mSampleRate,
                "bitDepth": format.mFormat.mBitsPerChannel,
            ]
        }
        let msg =
            "ä»\(JSON.stringify(simplifiedFormats))ä¸­æœªæ‰¾åˆ°åŒ¹é…ã€Œ\(depth)Bit \(rate)kHzã€çš„è¾“å‡ºæ ¼å¼"
        Log.notice.notice("æ ¼å¼åŒ¹é…å¤±è´¥", msg)
        Log.backend.info(
            msg
        )
        // æ¬¡é€‰ï¼šåŒ¹é…é‡‡æ ·ç‡ï¼Œä½¿ç”¨æ›´é«˜ä½æ·±
        if let rateMatch = formats.filter({
            Int($0.mFormat.mSampleRate) == rate
        }).sorted(by: {
            $0.mFormat.mBitsPerChannel > $1.mFormat.mBitsPerChannel
        }).first {
            return rateMatch
        }

        // æœ€åè¿”å›é»˜è®¤æ ¼å¼
        return formats.first!
    }
}


// ===============================
// FILE: ./AudioSync/service/PlaybackNotifier.swift
// ===============================
import AppKit
import CoreAudio
import ScriptingBridge
import SwiftUI

struct TrackInfo: Encodable, Equatable {
    let name: String
    let artist: String
    let albumArtist: String
    let trackID: String
    let album: String
    let state: PlayState
    let genre: String
    let color: [Color]?
    let albumCover: NSImage?
    enum CodingKeys: String, CodingKey {
        case name, artist, albumArtist, trackID, album, state, genre
    }
    static func == (lhs: TrackInfo, rhs: TrackInfo) -> Bool {
        return lhs.trackID == rhs.trackID
    }
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(artist, forKey: .artist)
        try container.encode(albumArtist, forKey: .albumArtist)
        try container.encode(trackID, forKey: .trackID)
        try container.encode(album, forKey: .album)
        try container.encode(state, forKey: .state)
        try container.encode(genre, forKey: .genre)
    }
}
enum PlayState: String, Encodable {
    case playing
    case stop
}
enum PlaybackTrigger {
    case formatSwitch
    case lyrics
}
@MainActor
class PlaybackNotifier {
    var onPlay: ((TrackInfo?, PlaybackTrigger) async -> Void)?

    private lazy var appleMusicScript: MusicApplication? = SBApplication(
        bundleIdentifier: "com.apple.Music"
    )
    var viewModel: ViewModel

    private var lastNotificationKey: String?
    var lock: Bool = false

    init(viewModel: ViewModel) {
        self.viewModel = viewModel
        DistributedNotificationCenter.default().addObserver(
            self,
            selector: #selector(receivedPlaybackNotification(_:)),
            name: NSNotification.Name("com.apple.Music.playerInfo"),
            object: nil
        )
    }

    deinit {
        DistributedNotificationCenter.default().removeObserver(self)
    }

    @objc private func receivedPlaybackNotification(
        _ notification: Notification
    ) {
        guard let userInfo = notification.userInfo,
            let state = userInfo["Player State"] as? String
        else {
            Log.backend.error(
                "appleNotification:  userInfo is missing required fields."
            )
            Log.notice.notice(
                "trackInfo is missing",
                "apple music distributedNotification"
            )
            return
        }

        let uniqueKey = userInfo.uniqueKey(using: [
            "Name", "Artist", "Album", "Player State",
        ])
        if uniqueKey == lastNotificationKey {
            return
        }
        lastNotificationKey = uniqueKey

        let songKey = userInfo.uniqueKey(using: [
            "Name", "Artist", "Album",
        ])
    
        viewModel.isCurrentTrackPlaying = (state == "Playing")
        Log.backend.info("appleNotification userInfo: \(userInfo)")
        let nextAlbum = userInfo["Album"] as? String ?? ""
        let nextName = userInfo["Name"] as? String ?? ""
        if !lock && state == "Playing" && !nextAlbum.isEmpty
            && viewModel.currentAlbum != nextAlbum && viewModel.enableAudioSync
        {
            lock = true
            Task {
                defer { lock = false }
                viewModel.currentAlbum = nextAlbum
                guard let script = self.appleMusicScript else { return }
                script.playpause?()
                Log.backend.info("pause \(nextName) â¹ï¸")
                if let onPlay = self.onPlay {
                    await onPlay(nil, .formatSwitch)  // ç­‰å¾…æ‰§è¡Œå®Œ
                }
                
                script.setPlayerPosition?(0.0)
                await waitUntilPaused(script)
                script.playpause?()
                Log.backend.info("play \(nextName) âœ…")

            }
        }
        if state != "Playing" {
            viewModel.isLyricsPlaying = false
        }
        let nextArtist = userInfo["Artist"] as? String ?? ""
        if songKey != viewModel.currentSong {
            viewModel.currentSong = songKey
            let genre = userInfo["Genre"] as? String ?? ""
            Task {
                let trackID = try await IDFetcher.fetchTrackID(
                    name: nextName,
                    artist: nextArtist
                )
                let albumData = try await IDFetcher.fetchArtworkData(
                    name: nextName,
                    artist: nextArtist
                )

                let trackInfo = TrackInfo(
                    name: nextName,
                    artist: nextArtist,
                    albumArtist: nextAlbum,
                    trackID: String(trackID),
                    album: nextAlbum,
                    state: stringFromPlayerState(state),
                    genre: genre,
                    color: albumData.findDominantColors(),
                    albumCover: albumData
                )
                viewModel.currentTrack = trackInfo
                if let onPlay = self.onPlay {
                    await onPlay(nil, .lyrics)
                }
            }

        } else {
            Log.backend.debug("è·³è¿‡é‡å¤é€šçŸ¥: \(nextName) - \(nextArtist)")
            Task {
                if let onPlay = self.onPlay {
                    await onPlay(nil, .lyrics)
                }
            }
        }

    }

    func stringFromPlayerState(_ state: String) -> PlayState {
        switch state {
        case "Playing": return .playing
        case "Paused": return .stop
        default: return .stop
        }
    }
    func waitUntilPaused(
        _ script: MusicApplication,
        timeout: Int = 50
    ) async {
        for i in 0..<timeout {
            let isPaused = await MainActor.run {
                script.playerState != .playing
            }

            if isPaused {
                Log.backend.info("waitUntilPaused active play time consuming : \(i * 80) ms")
                return
            }

            try? await Task.sleep(nanoseconds: 80_000_000)
        }
    }
}
extension Dictionary where Key == AnyHashable, Value == Any {
    func uniqueKey(using fields: [String]) -> String {
        let parts = fields.map { key -> String in
            if let value = self[key] {
                return "\(key)=\(value)"
            } else {
                return "\(key)=nil"
            }
        }
        return parts.joined(separator: "|").hashValue.description
    }
}


// ===============================
// FILE: ./AudioSync/utils/Log.swift
// ===============================
import OSLog
enum LogLevel: Int {
    case debug = 0
    case info = 1
    case warning = 2
    case error = 3
}
enum Log {
    static let subsystem = "com.solo.AudioSync"
    static let notice = AppLogger(subsystem: subsystem, category: "notice")
    static let general = AppLogger(subsystem: subsystem, category: "general")
    static let backend = AppLogger(subsystem: subsystem, category: "backend")
    static let ui = AppLogger(subsystem: subsystem, category: "ui")
}
/// å°è£… Loggerï¼Œæ”¯æŒå…¨å±€ç­‰çº§æ§åˆ¶
struct AppLogger {
    let logger: Logger
    let category: String
    
    static let globalLevel: LogLevel = .debug // å¯åŠ¨æ€ä¿®æ”¹
    
    init(subsystem: String, category: String) {
        self.logger = Logger(subsystem: subsystem, category: category)
        self.category = category
    }
    
    func debug(_ message: String) {
        guard AppLogger.globalLevel.rawValue <= LogLevel.debug.rawValue else { return }
        logger.debug("\(message, privacy: .public)")
    }
    
    func info(_ message: String) {
        guard AppLogger.globalLevel.rawValue <= LogLevel.info.rawValue else { return }
        logger.info("\(message, privacy: .public)")
    }
    
    func warning(_ message: String) {
        guard AppLogger.globalLevel.rawValue <= LogLevel.warning.rawValue else { return }
        logger.warning("\(message, privacy: .public)")
    }
    
    func error(_ message: String) {
        guard AppLogger.globalLevel.rawValue <= LogLevel.error.rawValue else { return }
        logger.error("\(message, privacy: .public)")
    }
    func notice(_ title: String , _ message: String) {
        NotificationUtils.sendNotification(title: title, body: message)
    }
}


// ===============================
// FILE: ./AudioSync/utils/NetworkUtil.swift
// ===============================
import AppKit
import Foundation

public class NetworkUtil {

    var viewModel: ViewModel
    let fakeSpotifyUserAgentconfig = URLSessionConfiguration.default
    let fakeSpotifyUserAgentSession: URLSession
    let coverCacheActor = CoverCache()
    var fetchSimilarArtistsAndCoversTask: Task<Void, Error>?
    init(viewModel: ViewModel) {
        fakeSpotifyUserAgentSession = URLSession(
            configuration: fakeSpotifyUserAgentconfig
        )
        self.viewModel = viewModel
    }
    func fetchLyrics(
        trackName: String,
        artist: String,
        trackID: String,
        album: String,
        genre: String
    ) async throws -> [LyricLine] {
        await MainActor.run {
            viewModel.allCandidates.removeAll()
            viewModel.needNanualSelection = false
        }
        var effectiveTrackName = trackName
        var effectiveArtist = artist
        var effectiveAlbum = album
        if ["J-Pop", "Kayokyoku", "J-Rock"].contains(genre) {
            Log.general.info("è·å–æ—¥æ–‡åŸå...")
            let originalNameResult = try await fetchOriginalName(
                trackName: trackName,
                artist: artist,
                album: album
            )
            let msg = "æ—¥æ–‡åŸå: \(JSON.stringify(originalNameResult))"
            Log.general.info("æ—¥æ–‡åŸå: \(JSON.stringify(originalNameResult))")
            Log.notice.notice("è·å–æ—¥æ–‡åŸåæˆåŠŸ", msg)
            if !originalNameResult.trackName.isEmpty {
                effectiveTrackName = originalNameResult.trackName
            }
            if !originalNameResult.artist.isEmpty {
                effectiveArtist = originalNameResult.artist
            }
            if !originalNameResult.album.isEmpty {
                effectiveAlbum = originalNameResult.album
            }
        }
        // å°è¯•ç½‘æ˜“äº‘éŸ³ä¹
        var lyrics = await fetchNetEaseLyrics(
            trackName: effectiveTrackName,
            artist: effectiveArtist,
            trackID: trackID,  // trackID ä¼¼ä¹æœªä½¿ç”¨ï¼Œä½†ä¿æŒç­¾åä¸€è‡´
            album: effectiveAlbum
        )
        if !lyrics.isEmpty {
            return lyrics
        }

        // å°è¯• QQ éŸ³ä¹
        lyrics = await fetchQQLyrics(
            trackName: effectiveTrackName,
            artist: effectiveArtist,
            album: effectiveAlbum
        )
        if !lyrics.isEmpty {
            return lyrics
        }

        // å¦‚æœä¸Šè¿°éƒ½å¤±è´¥ï¼Œå¹¶ä¸”æ”¶é›†åˆ°äº†å€™é€‰æ­Œæ›²ï¼Œåˆ™è§¦å‘æ‰‹åŠ¨é€‰æ‹©
        // å…ˆè·å–QQéŸ³ä¹çš„å°é¢
        await fetchAlbumCover()

        // æ£€æŸ¥æ˜¯å¦æœ‰å€™é€‰æ­Œæ›²ï¼Œå¹¶è§¦å‘æ‰‹åŠ¨é€‰æ‹©æµç¨‹
        // åœ¨ MainActor ä¸Šæ›´æ–° UI ç›¸å…³çŠ¶æ€
        await MainActor.run {
            var seen = Set<String>()
            viewModel.allCandidates.removeAll { candidate in
                if seen.contains(candidate.id) {
                    return true  // ç§»é™¤é‡å¤
                } else {
                    seen.insert(candidate.id)
                    return false
                }
            }
        }
        let shouldAskForManualSelection = await MainActor.run { () -> Bool in
            if !self.viewModel.allCandidates.isEmpty {
                self.viewModel.needNanualSelection = true
                Log.general.info("éœ€è¦æ‰‹åŠ¨é€‰æ‹© -> true")
                return true
            }
            return false
        }
        if shouldAskForManualSelection {
            Log.general.info("ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©...")
            // ä¸º continuation æ·»åŠ è¶…æ—¶æœºåˆ¶
            let continuationTimeout: TimeInterval = 20.0  // ä¾‹å¦‚ 10 ç§’è¶…æ—¶

            do {
                let selectedSong: CandidateSong =
                    try await withCheckedThrowingContinuation { continuation in
                        Task {
                            try? await Task.sleep(
                                nanoseconds: UInt64(
                                    continuationTimeout * 1_000_000_000
                                )
                            )
                            await MainActor.run {
                                if self.viewModel.onCandidateSelected != nil {
                                    Log.general.warning("âš ï¸ é€‰æ‹©è¶…æ—¶")
                                    Log.notice.notice("âš ï¸ é€‰æ‹©è¶…æ—¶", "")
                                    self.viewModel.onCandidateSelected = nil
                                    self.viewModel.needNanualSelection = false
                                    continuation.resume(
                                        throwing: FetchError
                                            .manualSelectionTimeout
                                    )
                                }
                            }
                        }

                        Task { @MainActor in
                            self.viewModel.onCandidateSelected = { song in
                                self.viewModel.onCandidateSelected = nil  // æ¸…ç†å›è°ƒ
                                continuation.resume(returning: song)
                            }
                        }
                    }
                // ç”¨æˆ·é€‰æ‹©åï¼Œæ ¹æ® ID è·å–æ­Œè¯
                return try await fetchLyricsByID(song: selectedSong)
            } catch FetchError.manualSelectionTimeout {
                await MainActor.run {
                    self.viewModel.needNanualSelection = false  // ç¡®ä¿UIçŠ¶æ€è¢«é‡ç½®
                    self.viewModel.isLyricsPlaying = false
                }
                return []  // æˆ–æŠ›å‡ºé”™è¯¯
            } catch {
                Log.general.error("æ‰‹åŠ¨é€‰æ‹©å‘ç”Ÿé”™è¯¯: \(error)")
                await MainActor.run {
                    self.viewModel.needNanualSelection = false  // ç¡®ä¿UIçŠ¶æ€è¢«é‡ç½®
                    self.viewModel.isLyricsPlaying = false
                }
                throw error  // é‡æ–°æŠ›å‡ºå…¶ä»–é”™è¯¯
            }
        }
        return []
    }

    // å®šä¹‰ä¸€ä¸ªé”™è¯¯ç±»å‹ç”¨äºè¶…æ—¶
    enum FetchError: Error {
        case manualSelectionTimeout
        case apiError(String)
        case parsingError(String)
    }

    func fetchNetEaseArtist(name: String) async throws -> Artist? {

        if let data = await coverCacheActor.get(for: name) {
            Log.backend.debug("å‘½ä¸­ \(name) ç¼“å­˜å°é¢")
            var artist = Artist(name: name)
            artist.image = data
            return artist
        }
        let request = URLRequest(
            url: URL(
                string:
                    "https://neteasecloudmusicapi-ten-wine.vercel.app/cloudsearch?keywords=\(name)&limit=1&type=100"
            )!
        )

        let response = try await fakeSpotifyUserAgentSession.data(for: request)
        let decoder = JSONDecoder()
        let netEaseArtists = try decoder.decode(
            NetEaseArtist.self,
            from: response.0
        )
        guard let netEaseArtist = netEaseArtists.result.artists.first else {
            return nil
        }
        let data = try await fetchImageData(netEaseArtist.picUrl)
        var artist = Artist(name: netEaseArtist.name, url: netEaseArtist.picUrl)
        artist.image = data
        Log.backend.info("æ‰¾åˆ°æ­Œæ‰‹ \(name) å°é¢ï¼š\(artist.url)")
        await coverCacheActor.set(artist.image!, for: name)
        return artist
    }
    func fetchSimilarArtistsAndCovers() {
        fetchSimilarArtistsAndCoversTask?.cancel()
        fetchSimilarArtistsAndCoversTask = Task {
            do {
                // 1. è·å–ç›¸ä¼¼æ­Œæ‰‹
                let fetched = try await fetchSimilarArtists(
                    name: viewModel.currentTrack?.artist ?? ""
                )
                await MainActor.run {
                    viewModel.similarArtists.removeAll()
                    viewModel.similarArtists = fetched
                }
                // 2. æŸ¥å°é¢
                await withTaskGroup(of: (Int, Data?).self) { group in
                    for i in await viewModel.similarArtists.indices {
                        if Task.isCancelled { break }
                        let name = await viewModel.similarArtists[i].name
                        group.addTask {
                            let cover = try? await self.fetchNetEaseArtist(
                                name: name
                            )
                            return (i, cover?.image)
                        }
                    }

                    for await (i, image) in group {
                        if Task.isCancelled { break }
                        if let image {
                            await MainActor.run {
                                viewModel.similarArtists[i].image = image
                            }
                        }
                    }
                }
            } catch {
                Log.ui.error("Failed to fetch similar artists: \(error)")
            }
        }
    }
    func fetchNetEaseLyrics(
        trackName: String,
        artist: String,
        trackID: String,
        album: String
    ) async -> [LyricLine] {
        if let url = URL(
            string:
                "https://neteasecloudmusicapi-ten-wine.vercel.app/cloudsearch?keywords=\(trackName) \(artist)&limit=5"
        ) {
            do {
                let request = URLRequest(url: url)
                let urlResponseAndData =
                    try await fakeSpotifyUserAgentSession.data(
                        for: request
                    )
                let decoder = JSONDecoder()
                let neteasesearch = try decoder.decode(
                    NetEaseSearch.self,
                    from: urlResponseAndData.0
                )
                Log.general.info("netease æ‰¾åˆ°æ­Œæ›²ï¼š\(neteasesearch.result.songs)")

                let matchedSong = neteasesearch.result.songs.first {
                    $0.name.normalized == trackName.normalized
                        && $0.ar.contains(where: {
                            $0.name.normalized == artist.normalized
                        })
                        && ($0.al.name.normalized == album.normalized
                            || album.normalized.contains(
                                $0.al.name.normalized
                            )
                            || $0.al.name.normalized.contains(
                                album.normalized
                            ))
                }

                guard let song = matchedSong else {
                    Log.general.info(
                        "âŒ æ²¡æœ‰åŒ¹é…åˆ° netease æ­Œæ›²ï¼štrackName=\(trackName), artist=\(artist), album=\(album)"
                    )
                    // Append all netease songs as candidates
                    for song in neteasesearch.result.songs {
                        let candidate = CandidateSong(
                            id: song.id.codingKey.stringValue,
                            name: song.name,
                            artist: song.ar.map { $0.name }.joined(
                                separator: ", "
                            ),
                            album: song.al.name,
                            albumId: song.al.id.codingKey.stringValue,
                            albumCover: song.al.picUrl,
                            source: .netEase
                        )
                        await MainActor.run {
                            viewModel.allCandidates.append(candidate)
                        }
                    }
                    return []
                }

                let lyricRequest = URLRequest(
                    url: URL(
                        string:
                            "https://neteasecloudmusicapi-ten-wine.vercel.app/lyric?id=\(song.id)"
                    )!
                )
                let urlResponseAndDataLyrics =
                    try await fakeSpotifyUserAgentSession.data(
                        for: lyricRequest
                    )

                let neteaseLyrics = try decoder.decode(
                    NetEaseLyrics.self,
                    from: urlResponseAndDataLyrics.0
                )

                guard let neteaselrc = neteaseLyrics.lrc,
                    let neteaseLrcString = neteaselrc.lyric
                else {
                    return []
                }

                let originalParser = LyricsParser(
                    lyrics: neteaseLrcString,
                    format: .netEase
                )
                var finalLyrics = originalParser.lyrics

                // åˆå¹¶æ­Œè¯ç¿»è¯‘
                if let tlyric = neteaseLyrics.tlyric,
                    let tlyricString = tlyric.lyric, !tlyricString.isEmpty
                {
                    let translationParser = LyricsParser(
                        lyrics: tlyricString,
                        format: .netEase
                    )
                    if !translationParser.lyrics.isEmpty {
                        finalLyrics = originalParser.mergeLyrics(
                            translation: translationParser
                        )
                    }
                }
                return finalLyrics
            } catch {
                Log.general.error("fetch netease lyrics:\(error)")
            }
        }
        return []
    }

    func fetchQQLyrics(trackName: String, artist: String, album: String)
        async -> [LyricLine]
    {
        if let url = URL(
            string:
                "https://c.y.qq.com/soso/fcgi-bin/client_search_cp?p=1&n=5&w=\(trackName) \(artist)"
        ) {
            do {
                let request = URLRequest(url: url)
                let urlResponseAndData =
                    try await fakeSpotifyUserAgentSession.data(
                        for: request
                    )
                guard
                    let rawText = String(
                        data: urlResponseAndData.0,
                        encoding: .utf8
                    ),
                    let rangeStart = rawText.range(of: "("),
                    let rangeEnd = rawText.range(of: ")", options: .backwards)
                else {
                    return []
                }
                let jsonString = String(
                    rawText[rangeStart.upperBound..<rangeEnd.lowerBound]
                )
                guard let jsonData = jsonString.data(using: .utf8) else {
                    return []
                }
                let decoder = JSONDecoder()
                let QQSearchData = try decoder.decode(
                    QQSearch.self,
                    from: jsonData
                )
                Log.general.info("qq æ‰¾åˆ°æ­Œæ›²:\(QQSearchData.data.song.list)")
                let QQSong = QQSearchData.data.song.list.first {
                    $0.songname.normalized == trackName.normalized
                        && $0.singer.contains(where: {
                            $0.name.normalized == artist.normalized
                        })
                        && ($0.albumname.normalized == album.normalized
                            || album.normalized.contains(
                                $0.albumname.normalized
                            )
                            || $0.albumname.normalized.contains(
                                album.normalized
                            ))
                }
                if QQSong == nil {
                    Log.general.info(
                        "âŒ æ²¡æœ‰åŒ¹é…åˆ° QQ æ­Œæ›²ï¼štrackName=\(trackName), artist=\(artist), album=\(album)"
                    )
                    // Append all QQ songs as candidates
                    for song in QQSearchData.data.song.list {
                        let candidate = CandidateSong(
                            id: song.songmid,
                            name: song.songname,
                            artist: song.singer.map { $0.name }.joined(
                                separator: ", "
                            ),
                            album: song.albumname,
                            albumId: song.albummid,
                            albumCover: "",
                            source: .qq
                        )
                        await MainActor.run {
                            viewModel.allCandidates.append(candidate)
                        }
                    }
                    return []
                }
                let url = URL(
                    string:
                        "https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg?songmid=\(QQSong!.songmid)&g_tk=5381"
                )!
                var lyricRequest = URLRequest(url: url)
                lyricRequest.setValue(
                    "y.qq.com/portal/player.html",
                    forHTTPHeaderField: "Referer"
                )

                let lyricResponseAndData =
                    try await fakeSpotifyUserAgentSession.data(
                        for: lyricRequest
                    )

                guard
                    let lyrRawText = String(
                        data: lyricResponseAndData.0,
                        encoding: .utf8
                    ),
                    let lyrRangeStart = lyrRawText.range(of: "("),
                    let lyrRangeEnd = lyrRawText.range(
                        of: ")",
                        options: .backwards
                    )
                else {
                    return []
                }
                let lyrJsonString = String(
                    lyrRawText[
                        lyrRangeStart.upperBound..<lyrRangeEnd.lowerBound
                    ]
                )
                guard let lyrJsonData = lyrJsonString.data(using: .utf8) else {
                    return []
                }

                let qqLyricsData = try decoder.decode(
                    QQLyrics.self,
                    from: lyrJsonData
                )
                guard let lyricString = qqLyricsData.lyricString else {
                    return []
                }
                let lyricsParser = LyricsParser(
                    lyrics: lyricString,
                    format: .qq
                )
                if let tlyricString = qqLyricsData.transString {
                    let tlyricsParser = LyricsParser(
                        lyrics: tlyricString,
                        format: .qq
                    )
                    return lyricsParser.mergeLyrics(translation: tlyricsParser)
                }
                return lyricsParser.lyrics
            } catch {
                Log.general.error("fetch qq lyrics : \(error)")
            }
        }
        return []
    }
    func fetchOriginalName(trackName: String, artist: String, album: String)
        async throws
        -> OriginalName
    {
        let url = URL(string: "https://api.siliconflow.cn/v1/chat/completions")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(
            "Bearer \(Key.siliconFlow)",
            forHTTPHeaderField: "Authorization"
        )
        let payload: [String: Any] = [
            "model": "deepseek-ai/DeepSeek-R1",
            "messages": [
                [
                    "role": "system",
                    "content":
                        "You are very familiar with Japanese music and proficient in Japanese (including Japanese-style Romanization). Help me find the original Japanese song title and artist name. Wrap the song title in <>, Wrap the album title in [] and the artist name in {},and if there is a year and the word 'live' they should be retained. Your answer should omit the thinking process and analysis. Response format example: <æ¶™ãã†ãã† 1997 live> [å—é¢¨] {å¤å· ã‚Šã¿} ",
                ],
                [
                    "role": "user",
                    "content": "æ­Œå: \(trackName), æ­Œæ‰‹: \(artist), ä¸“è¾‘: \(album)",
                ],
            ],
            "stream": false,
        ]

        request.httpBody = try JSONSerialization.data(
            withJSONObject: payload,
            options: []
        )

        let (data, _) = try await fakeSpotifyUserAgentSession.data(for: request)
        struct CompletionResponse: Decodable {
            struct Choice: Decodable {
                struct Message: Decodable {
                    let content: String
                }
                let message: Message
            }
            let choices: [Choice]
        }
        let decoder = JSONDecoder()
        let response = try decoder.decode(CompletionResponse.self, from: data)
        let rawContent = response.choices.first?.message.content ?? ""
        let originalName = rawContent.trimmingCharacters(
            in: CharacterSet(charactersIn: "<>")
        )
        let artist = rawContent.trimmingCharacters(
            in: CharacterSet(charactersIn: "{}")
        )
        let album = rawContent.trimmingCharacters(
            in: CharacterSet(charactersIn: "[]")
        )
        return OriginalName(
            trackName: originalName,
            artist: artist,
            album: album
        )
    }

    func fetchLyricsByID(song: CandidateSong) async throws -> [LyricLine] {
        switch song.source {
        case .netEase:
            let lyricRequest = URLRequest(
                url: URL(
                    string:
                        "https://neteasecloudmusicapi-ten-wine.vercel.app/lyric?id=\(song.id)"
                )!
            )
            let urlResponseAndDataLyrics =
                try await fakeSpotifyUserAgentSession.data(for: lyricRequest)
            let decoder = JSONDecoder()
            let neteaseLyrics = try decoder.decode(
                NetEaseLyrics.self,
                from: urlResponseAndDataLyrics.0
            )

            guard let neteaselrc = neteaseLyrics.lrc,
                let neteaseLrcString = neteaselrc.lyric
            else {
                return []
            }

            let originalParser = LyricsParser(
                lyrics: neteaseLrcString,
                format: .netEase
            )

            guard let tlrc = neteaseLyrics.tlyric, let tlrcString = tlrc.lyric
            else {
                return originalParser.lyrics
            }
            let translationParser = LyricsParser(
                lyrics: tlrcString,
                format: .netEase
            )
            return originalParser.mergeLyrics(translation: translationParser)
        case .qq:
            let url = URL(
                string:
                    "https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg?songmid=\(song.id)&g_tk=5381"
            )!
            var lyricRequest = URLRequest(url: url)
            lyricRequest.setValue(
                "y.qq.com/portal/player.html",
                forHTTPHeaderField: "Referer"
            )

            let lyricResponseAndData =
                try await fakeSpotifyUserAgentSession.data(for: lyricRequest)

            guard
                let lyrRawText = String(
                    data: lyricResponseAndData.0,
                    encoding: .utf8
                ),
                let lyrRangeStart = lyrRawText.range(of: "("),
                let lyrRangeEnd = lyrRawText.range(of: ")", options: .backwards)
            else {
                return []
            }
            let lyrJsonString = String(
                lyrRawText[lyrRangeStart.upperBound..<lyrRangeEnd.lowerBound]
            )
            guard let lyrJsonData = lyrJsonString.data(using: .utf8) else {
                return []
            }
            let decoder = JSONDecoder()
            let qqLyricsData = try decoder.decode(
                QQLyrics.self,
                from: lyrJsonData
            )
            guard let lyricString = qqLyricsData.lyricString else {
                return []
            }
            let lyricsParser = LyricsParser(lyrics: lyricString, format: .qq)
            if let tlyricString = qqLyricsData.transString {
                let tlyricsParser = LyricsParser(
                    lyrics: tlyricString,
                    format: .qq
                )
                return lyricsParser.mergeLyrics(translation: tlyricsParser)
            }
            return lyricsParser.lyrics
        }
    }
    func fetchAlbumCover() async {
        let qq = await MainActor.run { () -> ([String]) in
            var qqCandidates: [String] = []
            for candidate in viewModel.allCandidates {
                switch candidate.source {
                case .qq:
                    if !candidate.albumId.isEmpty {
                        qqCandidates.append(candidate.albumId)
                    }
                case .netEase:
                    break
                }
            }
            return qqCandidates
        }

        await withTaskGroup(of: (String, String).self) { group in
            for id in qq {
                group.addTask {
                    let cover =
                        (try? await self.fetchQQAlbumCoverByID(id: id)) ?? ""
                    return (id, cover)
                }
            }

            let coverMap = await group.reduce(into: [String: String]()) {
                $0[$1.0] = $1.1
            }

            await MainActor.run {
                for i in 0..<viewModel.allCandidates.count {
                    let candidate = viewModel.allCandidates[i]
                    if candidate.source == .qq,
                        let cover = coverMap[candidate.albumId]
                    {
                        viewModel.allCandidates[i].albumCover = cover
                    }
                }
            }
        }
    }
    func fetchQQAlbumCoverByID(id: String) async throws -> String {
        do {
            let albumRequest = URLRequest(
                url: URL(
                    string:
                        "https://c.y.qq.com/v8/fcg-bin/musicmall.fcg?albummid=\(id)&format=json&inCharset=utf-8&outCharset=utf-8&cmd=get_album_buy_page"
                )!
            )
            let albumData = try await fakeSpotifyUserAgentSession.data(
                for: albumRequest
            )
            let decoder = JSONDecoder()
            let album = try decoder.decode(QQAlbum.self, from: albumData.0)
            guard let pic = album.data.headpiclist.first?.picurl else {
                Log.general.error("è¾‘å°é¢è·å–å¤±è´¥: \(JSON.stringify(album))")
                return ""
            }
            Log.general.info("ä¸“è¾‘ url: \(pic) ")
            return pic

        } catch {
            Log.general.error("è·å–ä¸“è¾‘ \(error)")
        }
        return ""
    }
    func fetchSimilarArtists(name: String) async throws -> [Artist] {
        let request = URLRequest(
            url: URL(
                string:
                    "http://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=\(name)&api_key=\(Key.lastfm)&limit=10&format=json"
            )!
        )
        let response = try await fakeSpotifyUserAgentSession.data(for: request)
        let decoder = JSONDecoder()
        let artistResponse = try decoder.decode(
            ArtistFromLastFMResponse.self,
            from: response.0
        )
        guard let similars = artistResponse.similarartists?.artist else {
            return []
        }
        var similarArtists: [Artist] = []
        similars.forEach {
            let similarArtist = Artist(
                name: $0.name.toSimplified,
                url: $0.url,
                mbid: $0.mbid ?? ""
            )
            similarArtists.append(similarArtist)
        }
        return similarArtists
    }
    func fetchSimilarSongs(name: String, artist: String) async throws
        -> [SimilarSong]
    {
        let traditionalName = name.toTraditional

        // ç›¸åŒåˆ™æ‰§è¡ŒåŸæœ‰é€»è¾‘
        if traditionalName == name {
            let request = URLRequest(
                url: URL(
                    string:
                        "http://ws.audioscrobbler.com/2.0/?method=track.getsimilar&track=\(name)&artist=\(artist)&api_key=\(Key.lastfm)&limit=10&format=json"
                )!
            )
            let response = try await fakeSpotifyUserAgentSession.data(
                for: request
            )
            let decoder = JSONDecoder()
            let songsResponse = try decoder.decode(
                SongFromLastFMResponse.self,
                from: response.0
            )
            guard let similars = songsResponse.similartracks?.track else {
                Log.notice.notice("ç›¸ä¼¼æ­Œæ›²", "ä»lastfmæœªæ‰¾åˆ°ç›¸ä¼¼æ­Œæ›²")
                return []
            }
            var similarSongs: [SimilarSong] = []
            similars.forEach {
                let similarSong = SimilarSong(
                    name: $0.name.toSimplified,
                    mbid: $0.mbid ?? "",
                    artist: $0.artist.name.toSimplified
                )
                similarSongs.append(similarSong)
            }
            return similarSongs
        }

        // å¹¶å‘æ‰§è¡Œä¸¤ä¸ªè¯·æ±‚ï¼Œå–ç¬¬ä¸€ä¸ªæœ‰è¿”å›çš„
        return try await withThrowingTaskGroup(of: [SimilarSong].self) {
            group in
            // è¯·æ±‚1ï¼šåŸå
            group.addTask {
                let request = URLRequest(
                    url: URL(
                        string:
                            "http://ws.audioscrobbler.com/2.0/?method=track.getsimilar&track=\(name)&artist=\(artist)&api_key=\(Key.lastfm)&limit=10&format=json"
                    )!
                )
                let response = try await self.fakeSpotifyUserAgentSession.data(
                    for: request
                )
                let decoder = JSONDecoder()
                let songsResponse = try decoder.decode(
                    SongFromLastFMResponse.self,
                    from: response.0
                )
                guard let similars = songsResponse.similartracks?.track else {
                    return []
                }
                return similars.map {
                    SimilarSong(
                        name: $0.name.toSimplified,
                        mbid: $0.mbid ?? "",
                        artist: $0.artist.name.toSimplified
                    )
                }
            }

            // è¯·æ±‚2ï¼šç¹ä½“å
            group.addTask {
                let request = URLRequest(
                    url: URL(
                        string:
                            "http://ws.audioscrobbler.com/2.0/?method=track.getsimilar&track=\(traditionalName)&artist=\(artist)&api_key=\(Key.lastfm)&limit=10&format=json"
                    )!
                )
                let response = try await self.fakeSpotifyUserAgentSession.data(
                    for: request
                )
                let decoder = JSONDecoder()
                let songsResponse = try decoder.decode(
                    SongFromLastFMResponse.self,
                    from: response.0
                )
                guard let similars = songsResponse.similartracks?.track else {
                    return []
                }
                return similars.map {
                    SimilarSong(
                        name: $0.name.toSimplified,
                        mbid: $0.mbid ?? "",
                        artist: $0.artist.name.toSimplified
                    )
                }
            }

            // è°å…ˆè¿”å›éç©ºç»“æœå°±ç”¨è°
            for try await result in group {
                if !result.isEmpty {
                    group.cancelAll()
                    return result
                }
            }
            Log.notice.notice("ç›¸ä¼¼æ­Œæ›²", "ä½¿ç”¨ç®€ç¹æ­Œæ›²åä»lastfmæœªæ‰¾åˆ°ç›¸ä¼¼æ­Œæ›²")
            return []
        }
    }

    func fetchImageData(_ urlString: String) async throws -> Data {
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }

        let (data, _) = try await URLSession.shared.data(from: url)

        // ç›´æ¥å°è¯•å‹ç¼©
        return try await compressImageData(data, maxWidth: 300, quality: 0.7)
    }
}

extension String {

    var normalized: String {
        self
            .replacingOccurrences(
                of: #"\s+"#,
                with: " ",
                options: .regularExpression
            )
            .replacingOccurrences(of: "(", with: "-")
            .replacingOccurrences(of: ")", with: "-")
            .replacingOccurrences(of: "ï¼š", with: "-")
            .replacingOccurrences(of: "ï¼ˆ", with: "-")
            .replacingOccurrences(of: "ï¼‰", with: "-")
            .lowercased()
    }
    var toTraditional: String {
        self.applyingTransform(
            StringTransform("Simplified-Traditional"),
            reverse: false
        ) ?? self
    }

    var toSimplified: String {
        self.applyingTransform(
            StringTransform("Traditional-Simplified"),
            reverse: false
        ) ?? self
    }
}


// ===============================
// FILE: ./AudioSync/utils/NotificationUtils.swift
// ===============================
import UserNotifications
class NotificationUtils {
   static func sendNotification(title: String, body: String) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = UNNotificationSound.default
        
        // ç«‹å³å‘é€
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
        
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                Log.backend.error("å‘é€é€šçŸ¥å¤±è´¥: \(error)")
            }
        }
    }
}


// ===============================
// FILE: ./AudioSync/utils/Utils.swift
// ===============================
import AppKit
import Foundation

enum JSON {

    // MARK: - å¯¹è±¡/æ•°ç»„è½¬ JSON å­—ç¬¦ä¸²
    static func stringify<T: Encodable>(_ value: T, pretty: Bool = false)
        -> String
    {
        let encoder = JSONEncoder()
        if pretty {
            encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        }
        do {
            let data = try encoder.encode(value)
            return String(data: data, encoding: .utf8) ?? "{}"
        } catch {
            Log.general.error("JSON ç¼–ç å¤±è´¥: \(error)")
            return "{}"
        }
    }

    static func stringify(_ dict: [AnyHashable: Any], pretty: Bool = false)
        -> String
    {
        do {
            let data = try JSONSerialization.data(
                withJSONObject: dict,
                options: pretty ? [.prettyPrinted] : []
            )
            return String(data: data, encoding: .utf8) ?? "{}"
        } catch {
            Log.general.error("å­—å…¸ JSON ç¼–ç å¤±è´¥: \(error)")
            return "{}"
        }
    }

    static func stringify(_ array: [Any], pretty: Bool = false) -> String {
        do {
            let data = try JSONSerialization.data(
                withJSONObject: array,
                options: pretty ? [.prettyPrinted] : []
            )
            return String(data: data, encoding: .utf8) ?? "[]"
        } catch {
            Log.general.error("æ•°ç»„ JSON ç¼–ç å¤±è´¥: \(error)")
            return "[]"
        }
    }

    // MARK: - JSON å­—ç¬¦ä¸²è½¬å¯¹è±¡/æ•°ç»„
    static func parse<T: Decodable>(_ jsonString: String, to type: T.Type) -> T?
    {
        guard let data = jsonString.data(using: .utf8) else { return nil }
        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            Log.general.error("JSON è§£ç å¤±è´¥: \(error)")
            return nil
        }
    }

    static func parseDictionary(_ jsonString: String) -> [String: Any]? {
        guard let data = jsonString.data(using: .utf8) else { return nil }
        do {
            let obj = try JSONSerialization.jsonObject(with: data, options: [])
            return obj as? [String: Any]
        } catch {
            Log.general.error("JSON å­—ç¬¦ä¸²è½¬å­—å…¸å¤±è´¥: \(error)")
            return nil
        }
    }

    static func parseArray(_ jsonString: String) -> [Any]? {
        guard let data = jsonString.data(using: .utf8) else { return nil }
        do {
            let obj = try JSONSerialization.jsonObject(with: data, options: [])
            return obj as? [Any]
        } catch {
            Log.general.error("JSON å­—ç¬¦ä¸²è½¬æ•°ç»„å¤±è´¥: \(error)")
            return nil
        }
    }
}
func compressImageData(_ data: Data, maxWidth: CGFloat, quality: CGFloat)
    async throws -> Data
{
    guard let image = NSImage(data: data) else {
        throw NSError(domain: "InvalidImage", code: -1)
    }

    // å–å‡º CGImage
    guard
        let cgImage = image.cgImage(
            forProposedRect: nil,
            context: nil,
            hints: nil
        )
    else {
        throw NSError(domain: "InvalidCGImage", code: -1)
    }

    let originalWidth = CGFloat(cgImage.width)
    let originalHeight = CGFloat(cgImage.height)

    // å¦‚æœå›¾ç‰‡æœ¬æ¥å°±å¤Ÿå°ï¼Œç›´æ¥å­˜
    if originalWidth <= maxWidth {
        return data
    }

    // è®¡ç®—ç¼©æ”¾æ¯”
    let scale = maxWidth / originalWidth
    let newWidth = maxWidth
    let newHeight = originalHeight * scale

    // æ–°å›¾åƒ context
    let colorSpace = CGColorSpaceCreateDeviceRGB()

    guard
        let context = CGContext(
            data: nil,
            width: Int(newWidth),
            height: Int(newHeight),
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        )
    else {
        throw NSError(domain: "CreateContextFailed", code: -1)
    }

    context.interpolationQuality = .high
    context.draw(
        cgImage,
        in: CGRect(x: 0, y: 0, width: newWidth, height: newHeight)
    )

    guard let resizedCGImage = context.makeImage() else {
        throw NSError(domain: "ResizeFailed", code: -1)
    }

    // å¯¼å‡º JPEG æ•°æ®
    let rep = NSBitmapImageRep(cgImage: resizedCGImage)
    guard
        let jpegData = rep.representation(
            using: .jpeg,
            properties: [.compressionFactor: quality]
        )
    else {
        throw NSError(domain: "JPEGEncodeFailed", code: -1)
    }

    return jpegData
}
// MARK: - Encodable æ‰©å±•
extension Encodable {
    func toJSONString(pretty: Bool = false) -> String {
        JSON.stringify(self, pretty: pretty)
    }
}


// ===============================
// FILE: ./AudioSync/view/AnimatedMeshGradientView.swift
// ===============================
import SwiftUI
import MetalKit

struct AnimatedMeshGradientView: View {
    var colors: [Color]
    
    var body: some View {
        MetalMeshGradientView(colors: colors)
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .ignoresSafeArea()
    }
}

struct MetalMeshGradientView: NSViewRepresentable {
    var colors: [Color]
    
    func makeNSView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = context.coordinator.device
        mtkView.delegate = context.coordinator
        // è®¾ç½®èƒŒæ™¯é€æ˜ï¼Œä»¥ä¾¿ SwiftUI èƒŒæ™¯å¯ä»¥é€è¿‡
        mtkView.clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 0)
        mtkView.colorPixelFormat = .bgra8Unorm
        mtkView.framebufferOnly = false // éœ€è¦èƒ½å¤Ÿè¯»å– framebuffer å†…å®¹ï¼ˆè™½ç„¶è¿™é‡Œä¸ç›´æ¥è¯»å–ï¼Œä½†é€šå¸¸è®¾ä¸º false ä»¥å…é—®é¢˜ï¼‰
        mtkView.autoResizeDrawable = true
        mtkView.enableSetNeedsDisplay = true // å…è®¸æŒ‰éœ€é‡ç»˜
        mtkView.isPaused = false // ç¡®ä¿è§†å›¾ä¸æš‚åœ
        mtkView.preferredFramesPerSecond = 60 // ç›®æ ‡å¸§ç‡
        return mtkView
    }
    
    func updateNSView(_ nsView: MTKView, context: Context) {
        // å½“ SwiftUI è§†å›¾æ›´æ–°æ—¶ï¼Œé€šçŸ¥ Coordinator æ›´æ–°é¢œè‰²
        context.coordinator.updateColors(colors)
        // è¯·æ±‚é‡ç»˜
        nsView.setNeedsDisplay(nsView.bounds)
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(colors: colors)
    }
    
    class Coordinator: NSObject, MTKViewDelegate {
        let device: MTLDevice
        let commandQueue: MTLCommandQueue
        let pipelineState: MTLRenderPipelineState
        var vertexBuffer: MTLBuffer
        var timeBuffer: MTLBuffer
        var colorBuffer: MTLBuffer
        var gridPointsBuffer: MTLBuffer // å­˜å‚¨ç½‘æ ¼ç‚¹ä½ç½®
        var startTime: TimeInterval
        
        // é¡¶ç‚¹ç»“æ„ä½“
        struct Vertex {
            var position: SIMD2<Float>
        }
        
        // æ—¶é—´ uniform ç»“æ„ä½“
        struct TimeUniforms {
            var time: Float
        }
        
        // é¢œè‰² uniform ç»“æ„ä½“ (ç€è‰²å™¨ä¸­ä¼šå®šä¹‰ä¸ºæ•°ç»„)
        // struct ColorUniforms {
        //     var colors: [SIMD4<Float>] // å®é™…åœ¨ç€è‰²å™¨ä¸­æ˜¯ float4 colors[9]
        // }
        
        // ç½‘æ ¼ç‚¹ç»“æ„ä½“
        struct GridPoint {
            var position: SIMD2<Float>
        }

        // MovingPoint ç»“æ„ä½“
        struct MovingPoint {
            var position: SIMD2<Float>
            var direction: SIMD2<Float>
        }

        // å­˜å‚¨9ä¸ªåŠ¨æ€ç‚¹
        var movingPoints: [MovingPoint] = []
        
        init(colors: [Color]) {
            // è·å–é»˜è®¤ Metal è®¾å¤‡
            guard let device = MTLCreateSystemDefaultDevice(),
                  let commandQueue = device.makeCommandQueue() else {
                fatalError("Metal is not supported on this device")
            }
            
            self.device = device
            self.commandQueue = commandQueue
            self.startTime = CACurrentMediaTime() // è®°å½•å¼€å§‹æ—¶é—´ï¼Œç”¨äºåŠ¨ç”»
            
            // åˆ›å»ºæ¸²æŸ“ç®¡çº¿
            let library: MTLLibrary
            do {
                // ä» metalShaderSource å­—ç¬¦ä¸²ç¼–è¯‘ç€è‰²å™¨
                library = try device.makeLibrary(source: metalShaderSource, options: nil)
            } catch {
                fatalError("Failed to compile Metal shaders: \(error)")
            }

            guard let vertexFunction = library.makeFunction(name: "vertexShader"),
                  let fragmentFunction = library.makeFunction(name: "fragmentShader") else {
                fatalError("Failed to load shader functions from Metal library")
            }
            
            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.vertexFunction = vertexFunction
            pipelineDescriptor.fragmentFunction = fragmentFunction
            pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm // ä¸ MTKView æ ¼å¼åŒ¹é…

            // é…ç½®é¡¶ç‚¹æè¿°ç¬¦ (è™½ç„¶æˆ‘ä»¬çš„é¡¶ç‚¹ç€è‰²å™¨å¾ˆç®€å•ï¼Œä½†è¿™æ˜¯æ ‡å‡†åšæ³•)
            let vertexDescriptor = MTLVertexDescriptor()
            // å±æ€§0: ä½ç½®
            vertexDescriptor.attributes[0].format = .float2 // SIMD2<Float>
            vertexDescriptor.attributes[0].offset = 0
            vertexDescriptor.attributes[0].bufferIndex = 0 // å¯¹åº”é¡¶ç‚¹ç¼“å†²åŒºçš„ç´¢å¼•

            // å¸ƒå±€0: æè¿°é¡¶ç‚¹æ•°æ®å¦‚ä½•æ’åˆ—
            vertexDescriptor.layouts[0].stride = MemoryLayout<Vertex>.stride // å•ä¸ªé¡¶ç‚¹çš„æ­¥é•¿
            vertexDescriptor.layouts[0].stepRate = 1
            vertexDescriptor.layouts[0].stepFunction = .perVertex

            pipelineDescriptor.vertexDescriptor = vertexDescriptor
            
            do {
                pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
            } catch {
                fatalError("Failed to create pipeline state: \(error)")
            }
            
            // åˆ›å»ºé¡¶ç‚¹ç¼“å†²åŒº (ä¸€ä¸ªè¦†ç›–å…¨å±çš„å¤§ä¸‰è§’å½¢)
            // è¿™äº›åæ ‡æ˜¯å½’ä¸€åŒ–è®¾å¤‡åæ ‡ (NDC)
            let vertices: [Vertex] = [
                Vertex(position: SIMD2<Float>(-1, -1)), // å·¦ä¸‹
                Vertex(position: SIMD2<Float>(-1,  3)), // å·¦ä¸Šå»¶ä¼¸ (ç¡®ä¿è¦†ç›–)
                Vertex(position: SIMD2<Float>( 3, -1))  // å³ä¸‹å»¶ä¼¸ (ç¡®ä¿è¦†ç›–)
            ]
            
            vertexBuffer = device.makeBuffer(
                bytes: vertices,
                length: MemoryLayout<Vertex>.stride * vertices.count,
                options: .storageModeManaged // CPU å’Œ GPU å…±äº«å†…å­˜
            )!
            
            // åˆ›å»ºæ—¶é—´ç¼“å†²åŒº
            var initialTime = TimeUniforms(time: 0)
            timeBuffer = device.makeBuffer(
                bytes: &initialTime,
                length: MemoryLayout<TimeUniforms>.stride,
                options: .storageModeManaged
            )!
            
            // åˆ›å»ºé¢œè‰²ç¼“å†²åŒº (9ä¸ªé¢œè‰², æ¯ä¸ªé¢œè‰²æ˜¯ SIMD4<Float>)
            colorBuffer = device.makeBuffer(
                length: MemoryLayout<SIMD4<Float>>.stride * 9, // 9 ä¸ªé¢œè‰²
                options: .storageModeManaged
            )!
            
            // åˆ›å»ºç½‘æ ¼ç‚¹ç¼“å†²åŒº (9ä¸ªç‚¹, æ¯ä¸ªç‚¹æ˜¯ SIMD2<Float>)
            gridPointsBuffer = device.makeBuffer(
                length: MemoryLayout<GridPoint>.stride * 9, // 9 ä¸ªç½‘æ ¼ç‚¹
                options: .storageModeManaged
            )!
            
            super.init()

            // åˆå§‹åŒ–9ä¸ªéšæœºä½ç½®å’Œæ–¹å‘çš„movingPoints
            for _ in 0..<9 {
                let pos = SIMD2<Float>(
                    Float.random(in: 0.2...0.8),
                    Float.random(in: 0.2...0.8)
                )
                let angle = Float.random(in: 0..<2 * .pi)
                let dir = SIMD2<Float>(cos(angle), sin(angle))
                movingPoints.append(MovingPoint(position: pos, direction: dir))
            }

            // åˆå§‹åŒ–é¢œè‰²å’Œç½‘æ ¼ç‚¹
            updateColors(colors) // åˆå§‹é¢œè‰²åŠ è½½
            updateGridPoints(time: 0) // åˆå§‹ç½‘æ ¼ç‚¹ä½ç½®
        }
        
        func updateColors(_ swiftUIColors: [Color]) {
            // ç¡®ä¿æœ‰9ä¸ªé¢œè‰²ï¼Œå¦‚æœä¸å¤Ÿåˆ™éšæœºè¡¥å……
            var adjustedColors = swiftUIColors
            while adjustedColors.count < 9 {
                adjustedColors.append(adjustedColors.randomElement() ?? .blue) // é»˜è®¤è¡¥å……è“è‰²
            }
            
            // å°† SwiftUI Color è½¬æ¢ä¸º Metal ä½¿ç”¨çš„ SIMD4<Float> (RGBA)
            var floatColors: [SIMD4<Float>] = adjustedColors.prefix(9).map { color in
                // NSColor ç”¨äºæ›´å‡†ç¡®åœ°è·å– RGBA åˆ†é‡
                let nsColor = NSColor(color).usingColorSpace(.sRGB) ?? NSColor.blue
                return SIMD4<Float>(
                    Float(nsColor.redComponent),
                    Float(nsColor.greenComponent),
                    Float(nsColor.blueComponent),
                    Float(nsColor.alphaComponent)
                )
            }
            
            // æ›´æ–°é¢œè‰²ç¼“å†²åŒºå†…å®¹
            // `memcpy` ç”¨äºå°†æ•°æ®ä» `floatColors` æ•°ç»„å¤åˆ¶åˆ° Metal ç¼“å†²åŒºçš„å†…å­˜ä¸­
            memcpy(colorBuffer.contents(), &floatColors, MemoryLayout<SIMD4<Float>>.stride * 9)
            // é€šçŸ¥ Metal ç¼“å†²åŒºå†…å®¹å·²ä¿®æ”¹ (å¯¹äº .storageModeManaged)
            colorBuffer.didModifyRange(0..<colorBuffer.length)
        }
        
        func smoothRandom(_ seed: Float, time: Float) -> Float {
            // åŸºäº seed+time ç”Ÿæˆä¼ªéšæœºåºåˆ—ï¼ˆå¯æ›¿æ¢ä¸ºæ›´å¤æ‚æ’å€¼ï¼‰
            let sinS = sin(seed * 12.9898 + time * 0.19)
            let trunS = 43758.5453.truncatingRemainder(dividingBy: 1.0) * 2.0
            return sinS * Float(trunS) - 1.0
        }
        
        func updateGridPoints(time: Float) {
            let speed: Float = 0.0005 // æ§åˆ¶è¿åŠ¨é€Ÿåº¦

            for i in 0..<movingPoints.count {
                // æ›´æ–°ä½ç½®
                movingPoints[i].position += movingPoints[i].direction * speed

                // è¾¹ç¼˜ç¢°æ’æ£€æµ‹ + åå¼¹ï¼ˆä¿æŒåœ¨ [0, 1] èŒƒå›´å†…ï¼‰
                var pos = movingPoints[i].position
                var dir = movingPoints[i].direction

                if pos.x < 0.0 { pos.x = 0.0; dir.x *= -1 }
                if pos.x > 1.0 { pos.x = 1.0; dir.x *= -1 }
                if pos.y < 0.0 { pos.y = 0.0; dir.y *= -1 }
                if pos.y > 1.0 { pos.y = 1.0; dir.y *= -1 }

                movingPoints[i] = MovingPoint(position: pos, direction: dir)
            }

            // è½¬æ¢ä¸º GridPoint ä¼ ç»™ GPU
            let gridPoints = movingPoints.map { GridPoint(position: $0.position) }
            memcpy(gridPointsBuffer.contents(), gridPoints, MemoryLayout<GridPoint>.stride * 9)
            gridPointsBuffer.didModifyRange(0..<gridPointsBuffer.length)
        }
        
        // MTKViewDelegate æ–¹æ³•ï¼šå½“è§†å›¾å¤§å°æ”¹å˜æ—¶è°ƒç”¨
        func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
            // é€šå¸¸åœ¨è¿™é‡Œå¤„ç†æŠ•å½±çŸ©é˜µç­‰çš„æ›´æ–°ï¼Œä½†å¯¹äºè¿™ä¸ª2Dæ•ˆæœä¸æ˜¯å¿…éœ€çš„
        }
        
        // MTKViewDelegate æ–¹æ³•ï¼šæ¯å¸§ç»˜åˆ¶æ—¶è°ƒç”¨
        func draw(in view: MTKView) {
            // è·å–å½“å‰çš„ drawable å’Œ render pass descriptor
            guard let drawable = view.currentDrawable,
                  let renderPassDescriptor = view.currentRenderPassDescriptor else {
                return
            }
            // æ›´æ–°æ—¶é—´ uniform
            let currentTime = CACurrentMediaTime() - startTime // è®¡ç®—ç»è¿‡çš„æ—¶é—´
            var timeUniforms = TimeUniforms(time: Float(currentTime))
            memcpy(timeBuffer.contents(), &timeUniforms, MemoryLayout<TimeUniforms>.stride)
            timeBuffer.didModifyRange(0..<timeBuffer.length)
            
            // æ ¹æ®å½“å‰æ—¶é—´æ›´æ–°ç½‘æ ¼ç‚¹çš„ä½ç½®
            updateGridPoints(time: timeUniforms.time)
            
            // åˆ›å»ºå‘½ä»¤ç¼“å†²åŒº
            guard let commandBuffer = commandQueue.makeCommandBuffer(),
                  // åˆ›å»ºæ¸²æŸ“å‘½ä»¤ç¼–ç å™¨
                  let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) else {
                return
            }
            
            // è®¾ç½®æ¸²æŸ“ç®¡çº¿çŠ¶æ€
            renderEncoder.setRenderPipelineState(pipelineState)
            
            // è®¾ç½®é¡¶ç‚¹ç¼“å†²åŒº
            renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0) // é¡¶ç‚¹æ•°æ®
            // æ³¨æ„ï¼šæ—¶é—´ç¼“å†²åŒºåœ¨è¿™é‡Œæ²¡æœ‰ç›´æ¥ç»™é¡¶ç‚¹ç€è‰²å™¨ï¼Œå› ä¸ºé¡¶ç‚¹ä½ç½®æ˜¯å›ºå®šçš„ã€‚
            // å¦‚æœé¡¶ç‚¹ä¹Ÿéœ€è¦éšæ—¶é—´å˜åŒ–ï¼Œåˆ™éœ€è¦åœ¨è¿™é‡Œä¼ é€’ã€‚

            // è®¾ç½®ç‰‡æ®µç€è‰²å™¨æ‰€éœ€çš„ç¼“å†²åŒº
            renderEncoder.setFragmentBuffer(colorBuffer, offset: 0, index: 0)       // é¢œè‰²æ•°æ®
            renderEncoder.setFragmentBuffer(gridPointsBuffer, offset: 0, index: 1)  // ç½‘æ ¼ç‚¹ä½ç½®
            renderEncoder.setFragmentBuffer(timeBuffer, offset: 0, index: 2)        // æ—¶é—´æ•°æ® (ç‰‡æ®µç€è‰²å™¨ä¹Ÿå¯èƒ½éœ€è¦)
            
            // ç»˜åˆ¶ä¸‰è§’å½¢ (3ä¸ªé¡¶ç‚¹)
            renderEncoder.drawPrimitives(
                type: .triangle,
                vertexStart: 0,
                vertexCount: 3
            )
            
            // ç»“æŸç¼–ç 
            renderEncoder.endEncoding()
            
            // å‘ˆç° drawable
            commandBuffer.present(drawable)
            
            // æäº¤å‘½ä»¤ç¼“å†²åŒºæ‰§è¡Œ
            commandBuffer.commit()
        }
    }
}

// Metal ç€è‰²å™¨ä»£ç å­—ç¬¦ä¸²
// ä¿®æ”¹äº†ç‰‡æ®µç€è‰²å™¨ä»¥ä½¿ç”¨åè·ç¦»åŠ æƒæ³•æ¥æ··åˆé¢œè‰²
let metalShaderSource = """
#include <metal_stdlib>
using namespace metal;

// é¡¶ç‚¹ç€è‰²å™¨çš„è¾“å…¥ç»“æ„
struct VertexIn {
    float2 position [[attribute(0)]]; // ä»é¡¶ç‚¹ç¼“å†²åŒºè¯»å–çš„ä½ç½®å±æ€§
};

// é¡¶ç‚¹ç€è‰²å™¨çš„è¾“å‡ºç»“æ„ (ä¼ é€’ç»™ç‰‡æ®µç€è‰²å™¨)
struct VertexOut {
    float4 position [[position]]; // è£å‰ªç©ºé—´ä¸­çš„é¡¶ç‚¹ä½ç½® (å¿…éœ€)
    float2 uv;                   // çº¹ç†/å½’ä¸€åŒ–åæ ‡
};

// Uniform ç»“æ„ä½“ï¼Œä» CPU ä¼ é€’ç»™ GPU
struct TimeUniforms {
    float time;
};

struct ColorUniforms { // åœ¨ç€è‰²å™¨ä¸­ï¼Œæˆ‘ä»¬å°†ç›´æ¥ä½¿ç”¨ float4 colors[9]
    float4 colors[9]; // 9ä¸ªé¢œè‰²
};

struct GridPoint {
    float2 position; // ç½‘æ ¼ç‚¹çš„å½’ä¸€åŒ–ä½ç½®
};

// é¡¶ç‚¹ç€è‰²å™¨
vertex VertexOut vertexShader(
    VertexIn in [[stage_in]] // [[stage_in]] è¡¨ç¤ºè¿™æ˜¯é¡¶ç‚¹ç€è‰²å™¨çš„è¾“å…¥
) {
    VertexOut out;
    
    // ç›´æ¥å°†è¾“å…¥çš„2Dä½ç½®è½¬æ¢ä¸ºè£å‰ªç©ºé—´çš„4Dä½ç½®
    // z=0, w=1 æ˜¯2Dæ¸²æŸ“çš„å¸¸è§è®¾ç½®
    out.position = float4(in.position, 0.0, 1.0);
    
    // å°†è¾“å…¥çš„é¡¶ç‚¹ä½ç½®ä» [-1, 1] (NDCèŒƒå›´çš„ä¸€éƒ¨åˆ†) æ˜ å°„åˆ° [0, 1] çš„ UV åæ ‡
    // è¿™ä¸ª UV åæ ‡å°†è¦†ç›–æ•´ä¸ªæ¸²æŸ“åŒºåŸŸ
    out.uv = (in.position + 1.0) * 0.5; 
    
    return out;
}

// ç‰‡æ®µç€è‰²å™¨
fragment float4 fragmentShader(
    VertexOut in [[stage_in]], // ä»é¡¶ç‚¹ç€è‰²å™¨æ¥æ”¶æ’å€¼åçš„æ•°æ®
    constant float4 *colorsArray [[buffer(0)]],        // é¢œè‰²æ•°ç»„ (9ä¸ªé¢œè‰²)
    constant GridPoint *gridPoints [[buffer(1)]],   // ç½‘æ ¼ç‚¹æ•°ç»„ (9ä¸ªç‚¹)
    constant TimeUniforms &timeUniforms [[buffer(2)]] // æ—¶é—´ (å¦‚æœéœ€è¦ç›´æ¥åœ¨ç‰‡æ®µç€è‰²å™¨ä¸­ä½¿ç”¨)
) {
    float2 uv = in.uv; // å½“å‰ç‰‡æ®µçš„ UV åæ ‡ [0,1]
    
    float4 totalColor = float4(0.0); // åˆå§‹åŒ–ç´¯ç§¯é¢œè‰²
    float totalWeight = 0.0;         // åˆå§‹åŒ–ç´¯ç§¯æƒé‡
    
    // sharpness æ§åˆ¶é¢œè‰²ç‚¹çš„â€œé”åº¦â€æˆ–å½±å“èŒƒå›´
    // æ•°å€¼è¶Šå¤§ï¼Œå½±å“èŒƒå›´è¶Šå°ï¼Œé¢œè‰²ç‚¹è¶Šæ¸…æ™°ï¼›æ•°å€¼è¶Šå°ï¼Œæ··åˆè¶Šå¹³æ»‘æ¨¡ç³Š
    float sharpness = 10.0; // å¯ä»¥è°ƒæ•´è¿™ä¸ªå€¼ä»¥è·å¾—æœŸæœ›çš„æ•ˆæœ

    // éå†æ‰€æœ‰9ä¸ªç½‘æ ¼ç‚¹
    for (int i = 0; i < 9; ++i) {
        float2 pointPos = gridPoints[i].position;
        float2 offset = uv - pointPos;
        float dist = length(offset);
        float angleFactor = offset.x * 0.5 + offset.y * 1.5;
        float weight = exp(-sharpness * dist) * (1.0 + 0.8 * sin(angleFactor * 10.0));

        totalColor += colorsArray[i] * weight;
        totalWeight += weight;
    }

    float4 finalColor;
    if (totalWeight == 0.0 || totalWeight < 0.0001) { // é¿å…é™¤ä»¥é›¶æˆ–æå°çš„æƒé‡
        // å¦‚æœæ€»æƒé‡å‡ ä¹ä¸ºé›¶ (ä¾‹å¦‚åƒç´ ç¦»æ‰€æœ‰ç‚¹éƒ½å¾ˆè¿œï¼Œæˆ–è€… sharpness æé«˜)
        // å¯ä»¥è¿”å›ä¸€ä¸ªé»˜è®¤é¢œè‰²ï¼Œæˆ–è€…ç¬¬ä¸€ä¸ªç‚¹çš„é¢œè‰²ï¼Œæˆ–è€…é€æ˜
        finalColor = colorsArray[0]; 
    } else {
        finalColor = totalColor / totalWeight; // æ ‡å‡†åŒ–é¢œè‰²
    }
    
    // å¯ä»¥é€‰æ‹©æ€§åœ°å¯¹æœ€ç»ˆçš„ alpha è¿›è¡Œå¹³æ»‘å¤„ç†ï¼Œå¦‚æœéœ€è¦çš„è¯
    // finalColor.a = smoothstep(0.0, 1.0, finalColor.a); 
    // å¦‚æœé¢œè‰²æœ¬èº«å·²ç»åŒ…å«äº†alphaï¼Œå¹¶ä¸”å¸Œæœ›å®ƒå¹³æ»‘è¿‡æ¸¡ï¼Œå¯ä»¥ä¿ç•™æ­¤è¡Œã€‚
    // å¦‚æœå¸Œæœ›alphaç›´æ¥ç”±æ··åˆå†³å®šï¼Œå¯ä»¥æ³¨é‡Šæ‰ã€‚

    return finalColor;
}
"""


// ===============================
// FILE: ./AudioSync/view/FullScreenView.swift
// ===============================
import AppKit
import Combine
import SwiftUI

struct FullScreenView: View {
    @EnvironmentObject var viewmodel: ViewModel
    @State private var cachedColors: [Color] = []
    @Binding var isPresented: Bool

    var body: some View {
        Group {
            if isPresented {
                ZStack {
                    GeometryReader { geo in
                        HStack {
                            albumArt
                                .frame(
                                    minWidth: 0.50 * (geo.size.width),
                                    maxWidth: canDisplayLyrics
                                        ? 0.50 * (geo.size.width) : .infinity
                                )
                            if canDisplayLyrics {
                                LyricsPlayerViewWrapper(
                                    lyrics: viewmodel.currentlyPlayingLyrics,
                                    currentIndex: $viewmodel
                                        .currentlyPlayingLyricsIndex,
                                    geo: geo
                                )
                                .frame(
                                    minWidth: 0.50 * (geo.size.width),
                                    maxWidth: 0.50 * (geo.size.width)
                                )
                            }
                        }
                    }
                }
                .background {
                    ZStack {
                        if !cachedColors.isEmpty {
                            AnimatedMeshGradientView(
                                colors: cachedColors
                            )
                        }
                        Color.black.opacity(0.1)
                    }
                }
                .onAppear {
                    // ä¿®å¤ï¼šç¡®ä¿è§†å›¾å‡ºç°æ—¶åˆå§‹åŒ–é¢œè‰²å’Œæ­Œè¯
                    cachedColors = meshColors()
                }
                .onChange(of: viewmodel.currentTrack?.color) {
                    oldValue,
                    newValue in
                    cachedColors = meshColors()
                }
                // ä¿®å¤ï¼šç›‘å¬æ­Œè¯å˜åŒ–ä»¥ç¡®ä¿æ›´æ–°
                .onChange(of: viewmodel.currentlyPlayingLyrics) { _, newValue in
                    if !newValue.isEmpty {
                        cachedColors = meshColors()
                    }
                }
            }
        }
    }

    struct LyricsPlayerViewWrapper: NSViewRepresentable {
        let lyrics: [LyricLine]
        @Binding var currentIndex: Int?
        let geo: GeometryProxy
        let padding: CGFloat = 22
        let textHeight: CGFloat = 60
        var translationHeight: CGFloat = 0

        func makeNSView(context: Context) -> NSScrollView {
            let scrollView = NSScrollView()
            scrollView.hasVerticalScroller = true
            scrollView.autohidesScrollers = true
            scrollView.drawsBackground = false

            // åˆ›å»ºæ–‡æ¡£è§†å›¾å®¹å™¨
            let containerView = NSView()
            scrollView.documentView = containerView
            context.coordinator.containerView = containerView

            // è®¾ç½®æ»šåŠ¨è§†å›¾ä»£ç†
            scrollView.contentView.postsBoundsChangedNotifications = true
            NotificationCenter.default.addObserver(
                context.coordinator,
                selector: #selector(Coordinator.scrollViewDidScroll(_:)),
                name: NSView.boundsDidChangeNotification,
                object: scrollView.contentView
            )

            return scrollView
        }

        func updateNSView(_ scrollView: NSScrollView, context: Context) {
            let coordinator = context.coordinator
            coordinator.parent = self

            // æ›´æ–°æ­Œè¯è¡Œ
            updateLyricLines(
                coordinator: coordinator,
                scrollView: scrollView
            )

            // è‡ªåŠ¨æ»šåŠ¨é€»è¾‘
            if !coordinator.isUserScrolling {
                scrollToCurrentLyric(
                    coordinator: coordinator,
                    scrollView: scrollView
                )
            }

            // ä¼˜åŒ–ï¼šåªæ›´æ–°é™„è¿‘è¡Œçš„é€æ˜åº¦
            updateNearbyLineTransparencies(coordinator: coordinator)
        }

        private func updateLyricLines(
            coordinator: Coordinator,
            scrollView: NSScrollView
        ) {
            guard let containerView = coordinator.containerView else { return }

            // å¦‚æœæ­Œè¯æ•°é‡æ²¡æœ‰å˜åŒ–ï¼Œåªéœ€æ›´æ–°å—å½±å“çš„è¡Œ
            if coordinator.lastLyricsCount == lyrics.count {
                // ä¼˜åŒ–ï¼šåªæ›´æ–°å˜åŒ–çš„è¡Œ
                updateChangedLines(coordinator: coordinator)
                return
            }

            // æ¸…é™¤æ—§è§†å›¾
            containerView.subviews.forEach { $0.removeFromSuperview() }
            coordinator.lineViews.removeAll()

            // åˆ›å»ºæ–°æ­Œè¯è¡Œ
            var yOffset: CGFloat = 0
            let topSpacing = geo.size.height / 2.5
            let bottomSpacing = geo.size.height / 1.5

            // æ·»åŠ é¡¶éƒ¨é—´è·
            let topSpacer = NSView(
                frame: CGRect(
                    x: 0,
                    y: yOffset,
                    width: geo.size.width,
                    height: topSpacing
                )
            )
            containerView.addSubview(topSpacer)
            yOffset += topSpacing

            for (index, line) in lyrics.reversed().enumerated() {
                let reversedIndex = lyrics.count - 1 - index
                let isActive = reversedIndex == currentIndex
                var duration: Int = 0
                if reversedIndex < lyrics.count - 1 {
                    let nextTime = lyrics[reversedIndex + 1].startTimeMS
                    let currentTime = lyrics[reversedIndex].startTimeMS
                    duration = Int((nextTime - currentTime) * 1000)
                }
                // è®¡ç®—ç¿»è¯‘é«˜åº¦ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                let translationHeight: CGFloat =
                    if let translation = line.attachments[.translation()]?
                        .stringValue,
                        !translation.isEmpty
                    {
                        30  // ä¸ºç¿»è¯‘é¢„ç•™é¢å¤–é«˜åº¦
                    } else {
                        0
                    }
                let totalHeight = textHeight + translationHeight
                let lineView = LyricLineView(
                    element: line,
                    isActive: isActive,
                    fontName: NSFont.boldSystemFont(ofSize: 30).fontName,
                    currentIndex: currentIndex,
                    lineIndex: reversedIndex,
                    duration: duration,
                    totalHeight: totalHeight,
                    width: geo.size.width
                )

                lineView.frame = CGRect(
                    x: 0,
                    y: yOffset,
                    width: geo.size.width,  // ä½¿ç”¨geoçš„å®½åº¦ç¡®ä¿åˆå§‹å¸ƒå±€æ­£ç¡®
                    height: totalHeight
                )

                containerView.addSubview(lineView)
                yOffset += totalHeight + padding

                // å­˜å‚¨å¼•ç”¨
                coordinator.lineViews.append(lineView)
            }

            // æ·»åŠ åº•éƒ¨é—´è·
            let bottomSpacer = NSView(
                frame: CGRect(
                    x: 0,
                    y: yOffset,
                    width: geo.size.width,
                    height: bottomSpacing
                )
            )
            containerView.addSubview(bottomSpacer)
            yOffset += bottomSpacing

            // æ›´æ–°å®¹å™¨å¤§å°
            containerView.frame = CGRect(
                origin: .zero,
                size: CGSize(
                    width: geo.size.width,
                    height: yOffset
                )
            )

            // æ›´æ–°å†…å®¹å¤§å°
            scrollView.documentView?.setFrameSize(
                NSSize(width: geo.size.width, height: yOffset)
            )

            // è®°å½•å½“å‰æ­Œè¯æ•°é‡
            coordinator.lastLyricsCount = lyrics.count
            coordinator.lastCurrentIndex = currentIndex
        }

        // ä¼˜åŒ–ï¼šåªæ›´æ–°å˜åŒ–çš„è¡Œ
        private func updateChangedLines(coordinator: Coordinator) {
            guard let lastIndex = coordinator.lastCurrentIndex,
                let newIndex = currentIndex,
                lastIndex != newIndex
            else { return }

            // æ›´æ–°æ—§å½“å‰è¡Œ
            if let oldLineView = coordinator.lineViews.first(where: {
                $0.lineIndex == lastIndex
            }) {
                oldLineView.updateActiveState(isActive: false)
            }

            // æ›´æ–°æ–°å½“å‰è¡Œ
            if let newLineView = coordinator.lineViews.first(where: {
                $0.lineIndex == newIndex
            }) {
                newLineView.updateActiveState(isActive: true)
            }

            coordinator.lastCurrentIndex = newIndex
        }

        private func scrollToCurrentLyric(
            coordinator: Coordinator,
            scrollView: NSScrollView
        ) {
            guard let currentIndex = currentIndex,
                lyrics.indices.contains(currentIndex),
                let documentView = scrollView.documentView
            else { return }

            let topSpacing = geo.size.height / 2.5
            let totalLines = lyrics.count
            let visibleIndex = totalLines - 1 - currentIndex
            let lineViews = coordinator.lineViews
            let targetLineIndex = visibleIndex

            // ç´¯åŠ ç›®æ ‡è¡Œä¹‹å‰æ‰€æœ‰è¡Œçš„é«˜åº¦
            let yOffset = lineViews.prefix(targetLineIndex).reduce(CGFloat(0)) {
                partialResult,
                lineView in
                partialResult + lineView.totalHeight + padding
            }

            // å†åŠ ä¸Šç›®æ ‡è¡Œçš„ä¸€åŠé«˜åº¦è®©å®ƒå±…ä¸­
            let targetY =
                yOffset - (scrollView.contentSize.height - topSpacing) / 2
                + (lineViews[targetLineIndex].totalHeight / 2)
            // ç¡®ä¿ç›®æ ‡ä½ç½®åœ¨æœ‰æ•ˆèŒƒå›´å†…
            let maxY = documentView.frame.height - scrollView.contentSize.height
            let clampedY = min(max(targetY, 0), maxY)

            coordinator.isProgrammaticScroll = true
            NSAnimationContext.runAnimationGroup { context in
                context.duration = 1  // ç¼©çŸ­åŠ¨ç”»æ—¶é—´
                context.timingFunction = CAMediaTimingFunction(
                    name: .easeInEaseOut
                )
                scrollView.contentView.animator().setBoundsOrigin(
                    NSPoint(x: 0, y: clampedY)
                )
            } completionHandler: {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    coordinator.isProgrammaticScroll = false
                }
            }
        }

        // ä¼˜åŒ–ï¼šåªæ›´æ–°é™„è¿‘è¡Œçš„é€æ˜åº¦
        private func updateNearbyLineTransparencies(coordinator: Coordinator) {
            guard let currentIndex = currentIndex else { return }

            let visibleRange =
                max(
                    0,
                    currentIndex - 2
                )...min(
                    lyrics.count - 1,
                    currentIndex + 2
                )

            for lineView in coordinator.lineViews {
                if visibleRange.contains(lineView.lineIndex) {
                    lineView.updateTransparency(currentIndex: currentIndex)
                }
            }
        }

        func makeCoordinator() -> Coordinator {
            Coordinator(parent: self)
        }

        class Coordinator: NSObject {
            var parent: LyricsPlayerViewWrapper
            var isUserScrolling = false
            var containerView: NSView?
            var lineViews: [LyricLineView] = []
            var isProgrammaticScroll = false
            var lastLyricsCount = 0
            var lastCurrentIndex: Int? = nil  // è·Ÿè¸ªä¸Šä¸€æ¬¡çš„å½“å‰è¡Œç´¢å¼•

            init(parent: LyricsPlayerViewWrapper) {
                self.parent = parent
            }

            @objc func scrollViewDidScroll(_ notification: Notification) {
                guard !isProgrammaticScroll else { return }
                isUserScrolling = true
                NSObject.cancelPreviousPerformRequests(withTarget: self)
                perform(
                    #selector(resetScrollingFlag),
                    with: nil,
                    afterDelay: 1.0
                )
            }

            @objc private func resetScrollingFlag() {
                isUserScrolling = false
            }
        }
    }

    // MARK: - macOS æ­Œè¯è¡Œè§†å›¾ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    class LyricLineView: NSView {
        private let backgroundLabel = NSTextField()
        private let highlightLabel = NSTextField()
        private var element: LyricLine
        private var currentIndex: Int?
        let lineIndex: Int
        let duration: Int?
        let dispearMills = 500
        private var lastDistance: Int? = nil
        private var displayLink: CADisplayLink?
        private var animationStartTime: CFTimeInterval = 0
        private var animationDuration: CFTimeInterval = 0
        let totalHeight: CGFloat
        private let translationLabel = NSTextField()  // å°†ç¿»è¯‘æ ‡ç­¾æ”¹ä¸ºå±æ€§
        private var translationHeight: CGFloat = 0
        private let maxWidth: CGFloat
        init(
            element: LyricLine,
            isActive: Bool,
            fontName: String,
            currentIndex: Int?,
            lineIndex: Int,
            duration: Int?,
            totalHeight: CGFloat,
            width: CGFloat
        ) {
            self.element = element
            self.currentIndex = currentIndex
            self.lineIndex = lineIndex
            self.duration = duration
            self.totalHeight = totalHeight
            self.maxWidth = width
            super.init(frame: .zero)
            self.wantsLayer = true
            setupViews(isActive: isActive, fontName: fontName)
        }

        required init?(coder: NSCoder) {
            fatalError("init(coder:) has not been implemented")
        }

        private func setupViews(isActive: Bool, fontName: String) {
            // é…ç½®æ ‡ç­¾
            configureLabel(
                label: backgroundLabel,
                text: element.words,
                isActive: isActive,
                isHighlight: false,
                fontName: fontName
            )
            configureLabel(
                label: highlightLabel,
                text: element.words,
                isActive: isActive,
                isHighlight: true,
                fontName: fontName
            )

            // æ·»åŠ ç¿»è¯‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if let translation = element.attachments[.translation()]?
                .stringValue,
                !translation.isEmpty
            {
                translationHeight = 40  // ç¿»è¯‘è¡Œé«˜åº¦
                configureLabel(
                    label: translationLabel,
                    text: translation,
                    isActive: isActive,
                    isHighlight: true,
                    fontName: fontName,
                    isTranslation: true
                )
                addSubview(translationLabel)
            } else {
                translationHeight = 0
            }

            // æ·»åŠ å­è§†å›¾
            addSubview(backgroundLabel)
            addSubview(highlightLabel)

            // è®¾ç½®åˆå§‹é€æ˜åº¦
            updateTransparency(currentIndex: currentIndex)
        }

        func updateActiveState(isActive: Bool) {
            configureLabel(
                label: backgroundLabel,
                text: element.words,
                isActive: isActive,
                isHighlight: false,
                fontName: backgroundLabel.font?.fontName ?? ""
            )
            configureLabel(
                label: highlightLabel,
                text: element.words,
                isActive: isActive,
                isHighlight: true,
                fontName: highlightLabel.font?.fontName ?? ""
            )
        }

        func updateElement(element: LyricLine, isActive: Bool, fontName: String)
        {
            self.element = element
            backgroundLabel.stringValue = element.words
            highlightLabel.stringValue = element.words

            // æ›´æ–°ç¿»è¯‘
            if let translation = element.attachments[.translation()]?
                .stringValue, !translation.isEmpty
            {
                // æŸ¥æ‰¾ç°æœ‰çš„ç¿»è¯‘æ ‡ç­¾æˆ–åˆ›å»ºæ–°çš„
                var translationLabel: NSTextField?
                for subview in subviews {
                    if let label = subview as? NSTextField,
                        label != backgroundLabel && label != highlightLabel
                    {
                        translationLabel = label
                        break
                    }
                }

                if translationLabel == nil {
                    translationLabel = NSTextField()
                    translationLabel?.isEditable = false
                    translationLabel?.isBordered = false
                    translationLabel?.isBezeled = false
                    translationLabel?.drawsBackground = false
                    addSubview(translationLabel!)
                }

                configureLabel(
                    label: translationLabel!,
                    text: translation,
                    isActive: isActive,
                    isHighlight: true,
                    fontName: fontName,
                    isTranslation: true
                )
                translationLabel?.frame = CGRect(
                    x: 0,
                    y: 40,
                    width: bounds.width,
                    height: 20
                )
            } else {
                // ç§»é™¤ç¿»è¯‘æ ‡ç­¾ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                for subview in subviews {
                    if let label = subview as? NSTextField,
                        label != backgroundLabel && label != highlightLabel
                    {
                        label.removeFromSuperview()
                    }
                }
            }

            // æ›´æ–°é€æ˜åº¦
            updateTransparency(currentIndex: currentIndex)
        }

        func updateTransparency(currentIndex: Int?) {
            self.currentIndex = currentIndex
            guard let currentIndex = currentIndex else {
                alphaValue = 0.5
                return
            }

            // è®¡ç®—å½“å‰è¡Œä¸ç›®æ ‡è¡Œçš„è·ç¦»
            let distance = lineIndex - currentIndex

            if distance == -1 {
                // ç¡®ä¿åŠ¨ç”»åªåœ¨éœ€è¦æ—¶è§¦å‘
                if lastDistance == 0 || alphaValue > 0 {
                    startFadeOutAnimation()
                }
            }
            // å…¶ä»–æƒ…å†µç›´æ¥è®¾ç½®é€æ˜åº¦
            else {
                // æ ¹æ®è·ç¦»è®¾ç½®é€æ˜åº¦
                var opacity: CGFloat
                if distance == 0 {
                    opacity = 1.0
                } else if distance < -1 {
                    opacity = 0
                } else {
                    opacity = 0.5
                }

                // ç«‹å³è®¾ç½®é€æ˜åº¦
                NSAnimationContext.runAnimationGroup { context in
                    context.duration = 0.1
                    self.animator().alphaValue = opacity
                }
            }

            lastDistance = distance
        }

        private func configureLabel(
            label: NSTextField,
            text: String,
            isActive: Bool,
            isHighlight: Bool,
            fontName: String,
            isTranslation: Bool = false
        ) {
            // æ·»åŠ æ¢è¡Œæ”¯æŒ
            label.cell?.wraps = true
            label.cell?.isScrollable = false
            label.lineBreakMode = .byWordWrapping
            label.maximumNumberOfLines = 0
            label.stringValue = text
            label.isEditable = false
            label.isBordered = false
            label.isBezeled = false
            label.drawsBackground = false

            label.font = NSFont(name: fontName, size: isTranslation ? 24 : 38)

            if isActive {
                if isHighlight {
                    label.textColor = .white
                } else {
                    label.textColor = NSColor.white.withAlphaComponent(0.3)
                }
            } else {
                label.textColor = NSColor.white.withAlphaComponent(0.5)
            }

            let textHeight = calculateTextHeight(
                text: text,
                font: label.font,
                width: maxWidth
            )

            // å¦‚æœæ˜¯ç¿»è¯‘æ ‡ç­¾ï¼Œæ›´æ–°é«˜åº¦
            if isTranslation {
                translationHeight = textHeight
            }
        }
        // è®¡ç®—æ–‡æœ¬é«˜åº¦
        private func calculateTextHeight(
            text: String,
            font: NSFont?,
            width: CGFloat
        ) -> CGFloat {
            guard let font = font else { return 40 }

            let textRect = (text as NSString).boundingRect(
                with: CGSize(width: width, height: .greatestFiniteMagnitude),
                options: [.usesLineFragmentOrigin, .usesFontLeading],
                attributes: [.font: font],
                context: nil
            )

            return max(40, textRect.height)  // æœ€å°é«˜åº¦40
        }
        override func layout() {
            super.layout()
            backgroundLabel.frame = CGRect(
                x: 0,
                y: 0,
                width: bounds.width,
                height: 60  // å¢åŠ é«˜åº¦ä»¥é€‚åº”å¤šè¡Œ
            )
            highlightLabel.frame = backgroundLabel.frame

            // ç¿»è¯‘æ ‡ç­¾å¸ƒå±€
            if translationHeight > 0 {
                translationLabel.frame = CGRect(
                    x: 0,
                    y: backgroundLabel.frame.maxY + 5,
                    width: bounds.width,
                    height: translationHeight
                )
                translationLabel.isHidden = false
            } else {
                translationLabel.isHidden = true
            }

            // æ›´æ–°ç¿»è¯‘æ ‡ç­¾ä½ç½®å’Œé«˜åº¦
            for subview in subviews {
                if let label = subview as? NSTextField,
                    label != backgroundLabel && label != highlightLabel
                {
                    label.frame = CGRect(
                        x: 0,
                        y: 40,
                        width: bounds.width,
                        height: totalHeight - 40  // ä½¿ç”¨å‰©ä½™é«˜åº¦
                    )
                }
            }
        }

        private func startFadeOutAnimation() {
            // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„åŠ¨ç”»
            stopFadeOutAnimation()

            // è®¡ç®—åŠ¨ç”»æŒç»­æ—¶é—´
            animationDuration =
                Double(min(dispearMills, duration ?? dispearMills)) / 1000.0

            // è®¾ç½®åŠ¨ç”»å¼€å§‹æ—¶é—´
            animationStartTime = CACurrentMediaTime()
            // ä½¿ç”¨æ–°çš„ displayLink API
            displayLink = self.displayLink(
                target: self,
                selector: #selector(updateFadeAnimation)
            )
            displayLink?.add(to: .main, forMode: .common)
        }

        @objc private func updateFadeAnimation() {
            guard displayLink != nil else { return }

            let currentTime = CACurrentMediaTime()
            let elapsedTime = currentTime - animationStartTime
            let progress = min(1.0, CGFloat(elapsedTime / animationDuration))

            // åœ¨ä¸»çº¿ç¨‹å®‰å…¨æ›´æ–° UI
            DispatchQueue.main.async {
                self.alphaValue = 1.0 - progress

                if progress >= 1.0 {
                    self.stopFadeOutAnimation()
                }
            }
        }

        private func stopFadeOutAnimation() {
            if let token = displayLink {
                token.invalidate()
                displayLink = nil
            }
        }

        deinit {
            stopFadeOutAnimation()
        }
    }

    var canDisplayLyrics: Bool {
        viewmodel.isViewLyricsShow
    }

    func meshColors() -> [Color] {
        if var result = viewmodel.currentTrack?.color {
            while result.count < 9 {
                if let color = viewmodel.currentTrack?.color?.randomElement() {
                    result.append(color)
                }
            }
            return result
        }
        return []
    }

    @ViewBuilder var albumArt: some View {
        VStack {
            Spacer()
            if let album = viewmodel.currentTrack?.albumCover {
                Image(nsImage: album)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .clipShape(
                        .rect(
                            cornerRadii: .init(
                                topLeading: 10,
                                bottomLeading: 10,
                                bottomTrailing: 10,
                                topTrailing: 10
                            )
                        )
                    )
                    .shadow(radius: 5)
                    .frame(
                        width: canDisplayLyrics ? 450 : 700,
                        height: canDisplayLyrics ? 450 : 700
                    )
            } else {
                Image(systemName: "music.note.list")
                    .resizable()
                    .shadow(radius: 3)
                    .scaleEffect(0.5)
                    .background(.gray)
                    .clipShape(
                        .rect(
                            cornerRadii: .init(
                                topLeading: 10,
                                bottomLeading: 10,
                                bottomTrailing: 10,
                                topTrailing: 10
                            )
                        )
                    )
                    .shadow(radius: 5)
                    .frame(
                        width: canDisplayLyrics ? 450 : 650,
                        height: canDisplayLyrics ? 450 : 650
                    )
            }
            Group {
                Text(verbatim: viewmodel.currentTrack?.name ?? "")
                    .font(
                        .custom(
                            NSFont.boldSystemFont(ofSize: 28).fontName,
                            size: 28
                        )
                    )
                    .bold()
                    .foregroundStyle(.white)
                    .padding(.top, 30)
                    .lineLimit(2)
                    .multilineTextAlignment(.center)
                    .frame(maxWidth: (canDisplayLyrics ? 450 : 650) * 0.9)
                Text(verbatim: viewmodel.currentTrack?.artist ?? "")
                    .font(
                        .custom(
                            NSFont.boldSystemFont(ofSize: 22).fontName,
                            size: 22
                        )
                    )
                    .foregroundStyle(.white)
                    .opacity(0.7)
            }
            .frame(height: 35)
            HStack {
                Button {
                    viewmodel.isViewLyricsShow.toggle()
                } label: {
                    Image(systemName: "music.note.list")
                }
                .disabled(viewmodel.currentlyPlayingLyrics.isEmpty)
            }
            Spacer()
        }
    }

}


// ===============================
// FILE: ./AudioSync/view/KaraokeView.swift
// ===============================
//
//  KaraokeView.swift
//  AudioSync
//
//  Created by solo on 5/12/25.
//

import SwiftUI

struct KaraokeView: View {

    @EnvironmentObject var viewmodel: ViewModel
    func multilingualView(_ currentlyPlayingLyricsIndex: Int) -> some View {
        VStack(spacing: 6) {
            Text(
                verbatim: viewmodel.currentlyPlayingLyrics[
                    currentlyPlayingLyricsIndex
                ].words
            )
            if let trlycs = viewmodel.currentlyPlayingLyrics[
                currentlyPlayingLyricsIndex
            ].attachments[.translation()]?.stringValue, !trlycs.isEmpty {
                Text(verbatim: trlycs)
                    .font(
                        .custom(
                            viewmodel.karaokeFont.fontName,
                            size: 0.9 * (viewmodel.karaokeFont.pointSize)
                        )
                    )
                //                    .opacity(0.85)
            }
        }
    }

    @ViewBuilder func lyricsView() -> some View {
        if let currentlyPlayingLyricsIndex = viewmodel
            .currentlyPlayingLyricsIndex,
            viewmodel.currentlyPlayingLyrics.indices.contains(
                currentlyPlayingLyricsIndex
            ),
            !viewmodel.currentlyPlayingLyrics[currentlyPlayingLyricsIndex].words
                .isEmpty
        {
            multilingualView(currentlyPlayingLyricsIndex)
        } else {
            Text("Â·Â·Â·")
        }
    }
    var body: some View {
        lyricsView()
            .lineLimit(2)
            .foregroundStyle(.white)
            .minimumScaleFactor(0.9)
            .font(
                .custom(
                    viewmodel.karaokeFont.fontName,
                    size: viewmodel.karaokeFont.pointSize
                )
            )
            .padding(10)
            .padding(.horizontal, 10)
            .background {
                VisualEffectView().ignoresSafeArea()
                if let colors = viewmodel.currentTrack?.color {
                    if !colors.isEmpty {
                        ZStack {
                            LinearGradient(
                                gradient: Gradient(
                                    colors: colors
                                ),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                            Color.black.opacity(0.1)
                        }
                    }
                }

            }
            .cornerRadius(16)
            .multilineTextAlignment(.center)
            .frame(
                minWidth: 800,
                maxWidth: 800,
                minHeight: 100,
                maxHeight: 100,
                alignment: .center
            )

    }
}
struct VisualEffectView: NSViewRepresentable {
    func makeNSView(context: Context) -> NSVisualEffectView {
        let view = NSVisualEffectView()

        view.blendingMode = .behindWindow
        view.state = .active
        view.material = .popover

        return view
    }

    func updateNSView(_ nsView: NSVisualEffectView, context: Context) {

        nsView.material = .popover
        nsView.blendingMode = .behindWindow
    }
}
//#Preview {
//    KaraokeView()
//        .environmentObject(ViewModel.preview)
//}


// ===============================
// FILE: ./AudioSync/view/LyricsSelectorView.swift
// ===============================
//
//  LyricsSelectorView.swift
//  AudioSync
//
//  Created by solo on 5/19/25.
//
import SwiftUI

struct LyricsSelectorView: View {
    @EnvironmentObject var viewModel: ViewModel

    var body: some View {
        ZStack {
            VStack(alignment: .leading, spacing: 0) {
                // å›ºå®š currentTrack æ˜¾ç¤º
                if let trackName = viewModel.currentTrack?.name {
                    HStack(spacing: 12) {
                        // å·¦ä¾§å°é¢ï¼ˆåœ†è§’å°é¢å›¾ç‰‡ï¼Œæ”¯æŒ NSImage è½¬æ¢ï¼›æ— å›¾æ—¶æ˜¾ç¤ºé»˜è®¤å ä½å›¾å½¢ï¼‰
                        if let albumCover = viewModel.currentTrack?.albumCover {
                            albumCover.toSwiftUIImage()
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 45, height: 45)
                                .clipShape(RoundedRectangle(cornerRadius: 4))
                        } else {
                            RoundedRectangle(cornerRadius: 4)
                                .fill(Color(NSColor.controlAccentColor))
                                .frame(width: 45, height: 45)
                        }

                        // æ­Œæ›²å + è‰ºäººä¿¡æ¯
                        VStack(alignment: .leading, spacing: 2) {
                            Text("\(trackName)")
                                .font(.system(size: 15, weight: .semibold))
                                .foregroundColor(Color(NSColor.labelColor))

                            if let artist = viewModel.currentTrack?.artist {
                                Text(artist)
                                    .font(.system(size: 13))
                                    .foregroundColor(Color(NSColor.secondaryLabelColor))
                            }
                        }

                        Spacer()
                        
                        Button(action: {
                            withAnimation {
                                viewModel.needNanualSelection = false
                                viewModel.onCandidateSelected = nil
                            }
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(Color.green.opacity(0.6))
                                .imageScale(.large)
                        }
                        .buttonStyle(.plain)
                        .help("å–æ¶ˆé€‰æ‹©")
                    }
                    .padding(.horizontal, 16)
                    .padding(.bottom, 5)
                    .padding(.top, 5)
                }
                // æ»šåŠ¨å€™é€‰é¡¹
                ScrollView(.vertical, showsIndicators: true) {
                    LazyVStack(spacing: 0) {
                        ForEach(viewModel.allCandidates, id: \.id) { song in
                            CandidateRow(song: song, viewModel: viewModel) // æå–å­è§†å›¾
                                .frame(height: 42) // å›ºå®šè¡Œé«˜
                                .padding(.horizontal)
                            
                            Divider()
                                .background(Color(NSColor.separatorColor))
                                .padding(.horizontal)
                        }
                    }
                    .padding(.top, 8)
                }
            }
            .frame(width: 420, height: 450) // å›ºå®šå°ºå¯¸
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(NSColor.windowBackgroundColor).opacity(0.9))
                    .shadow(color: .black.opacity(0.2), radius: 8, y: 4)
            )
            .padding(20)
        }
    }

    // æå–å­è§†å›¾
    private struct CandidateRow: View {
        let song: CandidateSong // å‡è®¾Songæ˜¯ä½ çš„æ•°æ®æ¨¡å‹
        let viewModel: ViewModel
        @State private var isHovered = false
        
        var body: some View {
            Button(action: selectSong) {
                HStack {
                    if  !song.albumCover.isEmpty, let url = URL(string: song.albumCover) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            RoundedRectangle(cornerRadius: 4)
                                .fill(Color(NSColor.controlAccentColor).opacity(0.3))
                        }
                        .frame(width: 40, height: 40)
                        .clipShape(RoundedRectangle(cornerRadius: 4))
                    } else {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(Color(NSColor.controlAccentColor))
                            .frame(width: 40, height:40)
                    }
                    // æ°´å¹³æ»šåŠ¨æ–‡æœ¬å®¹å™¨
                    ScrollView(.horizontal, showsIndicators: false) {
                        Text("\(song.name) - \(song.artist) - \(song.album)")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(Color(NSColor.secondaryLabelColor))
                            .padding(.horizontal, 16)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }
                .frame(height: 42)
                .background(isHovered ? Color.blue.opacity(0.6) : Color.clear) // æ‚¬åœèƒŒæ™¯
                .cornerRadius(8)
                .contentShape(Rectangle()) // ç¡®ä¿æ•´ä¸ªåŒºåŸŸå¯ç‚¹å‡»
            }
            .buttonStyle(.plain)
            .onHover { hovering in
                withAnimation(.easeInOut(duration: 0.15)) {
                    isHovered = hovering
                }
            }
        }
        
        private func selectSong() {
            withAnimation {
                viewModel.needNanualSelection = false
                viewModel.onCandidateSelected?(song)
                viewModel.onCandidateSelected = nil
            }
        }
    }
}


// ===============================
// FILE: ./AudioSync/view/SimilarArtistView.swift
// ===============================
//
//  SimilarArtist.swift
//  AudioSync
//
//  Created by solo on 11/6/25.
//

import SwiftUI

struct SimilarArtistView: View {
    @EnvironmentObject var viewmodel: ViewModel
    var body: some View {
        if let artist = viewmodel.currentTrack?.artist {
            HStack(spacing: 8) {
                Spacer()
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        Text("\(artist)")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(Color(NSColor.secondaryLabelColor))
                            .frame(maxWidth: .infinity, alignment: .center)
                    }
                    .frame(minWidth: 120)
                }
                .frame(width: 120)
                Text(" ç›¸ä¼¼æ­Œæ‰‹")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(
                        Color(NSColor.secondaryLabelColor)
                    )
                    .frame(width: 70)
                Button(action: {
                    withAnimation {
                        viewmodel.refreshSimilarArtist = true
                    }
                }) {
                    Image(systemName: "arrow.clockwise.circle")
                        .font(.system(size: 18))  // æ”¾å¤§æŒ‰é’®å›¾æ ‡
                        .foregroundColor(.secondary)  // ä¸æ•´ä½“é…è‰²ä¸€è‡´
                        .background(Color.clear)  // èƒŒæ™¯é€æ˜
                        .contentShape(Circle())  // æ‰©å¤§ç‚¹å‡»èŒƒå›´ä½†ä¿æŒé€æ˜
                }
                .buttonStyle(PlainButtonStyle())
                Spacer()
            }
            .padding(5)
            .frame(width: 250)
        }
        ScrollView {
            LazyVStack(spacing: 12) {
                ForEach(0..<viewmodel.similarArtists.count, id: \.self) { i in
                    Button(action: {
                        openMusic(artist: viewmodel.similarArtists[i].name)
                    }) {
                        HStack(alignment: .center, spacing: 18) {
                            if let image = viewmodel.similarArtists[i].image,
                                let nsImage = NSImage(data: image)
                            {
                                Image(nsImage: nsImage)
                                    .resizable()
                                    .frame(width: 45, height: 45)
                                    .clipShape(
                                        RoundedRectangle(cornerRadius: 4)
                                    )
                            } else {
                                Image(systemName: "person.crop.square")
                                    .frame(width: 45, height: 45)
                                    .clipShape(
                                        RoundedRectangle(cornerRadius: 4)
                                    )
                            }

                            ScrollView(.horizontal, showsIndicators: false) {
                                Text(viewmodel.similarArtists[i].name)
                                    .font(.system(size: 16, weight: .medium))
                                    .foregroundColor(
                                        Color(NSColor.secondaryLabelColor)
                                    )
                                    .padding()
                            }
                            .frame(width: 120, alignment: .center)

                        }
                        .padding()
                        .frame(maxWidth: .infinity, alignment: .center)
                        .background(
                            RoundedRectangle(cornerRadius: 10)
                                .fill(
                                    Color(NSColor.windowBackgroundColor)
                                        .opacity(
                                            0.15
                                        )
                                )
                        )
                    }
                    .contentShape(Rectangle())
                    .buttonStyle(PlainButtonStyle())  // å»æ‰é»˜è®¤è“è‰²æŒ‰é’®æ•ˆæœ
                    .frame(height: 50)
                    Divider()
                }
            }
        }
        .cornerRadius(10)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color(NSColor.controlBackgroundColor))  // æ•´ä½“èƒŒæ™¯è‰²
        //.padding(.vertical, 16)
    }
    private func openMusic(artist: String) {
        Task {
            let artistID = try await IDFetcher.fetchArtistID(
                name: "",
                artist: artist
            )
            // æ­¥éª¤ 2: ä½¿ç”¨ ID è·³è½¬åˆ°è‰ºæœ¯å®¶ä¸»é¡µ (ä½¿ç”¨ Universal Linkï¼Œå¦‚ MusicNavigator ä¸­æ‰€æ¨è)
            _ = try MusicNavigator.openArtistPage(
                by: String(artistID)
            )
        }
    }
}

#Preview {
    let previewViewModel: ViewModel = {
        let vm = ViewModel()
        vm.currentTrack = TrackInfo(
            name: "nextName",
            artist: "nextArtist",
            albumArtist: "nextAlbum",
            trackID: "trackID",
            album: "nextAlbum",
            state: .playing,
            genre: "genre",
            color: [],
            albumCover: nil
        )
        vm.similarArtists = [
            Artist(name: "Artist A", url: ""),
            Artist(name: "Artist B", url: ""),
            Artist(name: "Artist C", url: ""),
        ]
        return vm
    }()

    SimilarArtistView()
        .environmentObject(previewViewModel)
}


// ===============================
// FILE: ./AudioSync/view/SimilarSongView.swift
// ===============================
//
//  SimilarSongView.swift
//  AudioSync
//
//  Created by solo on 5/19/25.
//
import SwiftUI

struct SimilarSongView: View {
    @EnvironmentObject var viewModel: ViewModel

    var body: some View {
        ZStack {
            VStack(alignment: .leading, spacing: 0) {
                // å›ºå®š currentTrack æ˜¾ç¤º
                if let trackName = viewModel.currentTrack?.name {
                    HStack(spacing: 12) {
                        // å·¦ä¾§å°é¢ï¼ˆåœ†è§’å°é¢å›¾ç‰‡ï¼Œæ”¯æŒ NSImage è½¬æ¢ï¼›æ— å›¾æ—¶æ˜¾ç¤ºé»˜è®¤å ä½å›¾å½¢ï¼‰
                        if let albumCover = viewModel.currentTrack?.albumCover {
                            albumCover.toSwiftUIImage()
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 45, height: 45)
                                .clipShape(RoundedRectangle(cornerRadius: 4))
                        } else {
                            RoundedRectangle(cornerRadius: 4)
                                .fill(Color(NSColor.controlAccentColor))
                                .frame(width: 45, height: 45)
                        }

                        // æ­Œæ›²å + è‰ºäººä¿¡æ¯
                        VStack(alignment: .leading, spacing: 2) {
                            Text("\(trackName)")
                                .font(.system(size: 15, weight: .semibold))
                                .foregroundColor(Color(NSColor.labelColor))

                            if let artist = viewModel.currentTrack?.artist {
                                Text(artist)
                                    .font(.system(size: 13))
                                    .foregroundColor(
                                        Color(NSColor.secondaryLabelColor)
                                    )
                            }
                        }

                        Spacer()

                        Button(action: {
                            withAnimation {
                                viewModel.needNanualSelection = false
                                viewModel.onCandidateSelected = nil
                            }
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(Color.green.opacity(0.6))
                                .imageScale(.large)
                        }
                        .buttonStyle(.plain)
                        .help("å–æ¶ˆé€‰æ‹©")
                    }
                    .padding(.horizontal, 16)
                    .padding(.bottom, 5)
                    .padding(.top, 5)
                }
                // æ»šåŠ¨å€™é€‰é¡¹
                ScrollView(.vertical, showsIndicators: true) {
                    LazyVStack(spacing: 0) {
                        ForEach(viewModel.allCandidates, id: \.id) { song in
                            CandidateRow(song: song, viewModel: viewModel)  // æå–å­è§†å›¾
                                .frame(height: 42)  // å›ºå®šè¡Œé«˜
                                .padding(.horizontal)

                            Divider()
                                .background(Color(NSColor.separatorColor))
                                .padding(.horizontal)
                        }
                    }
                    .padding(.top, 8)
                }
            }
            .frame(width: 420, height: 450)  // å›ºå®šå°ºå¯¸
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(NSColor.windowBackgroundColor).opacity(0.9))
                    .shadow(color: .black.opacity(0.2), radius: 8, y: 4)
            )
            .padding(20)
        }
    }

    // æå–å­è§†å›¾
    private struct CandidateRow: View {
        let song: CandidateSong  // å‡è®¾Songæ˜¯ä½ çš„æ•°æ®æ¨¡å‹
        let viewModel: ViewModel
        @State private var isHovered = false

        var body: some View {
            Button(action: selectSong) {
                HStack {
                    if !song.albumCover.isEmpty,
                        let url = URL(string: song.albumCover)
                    {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            RoundedRectangle(cornerRadius: 4)
                                .fill(
                                    Color(NSColor.controlAccentColor).opacity(
                                        0.3
                                    )
                                )
                        }
                        .frame(width: 40, height: 40)
                        .clipShape(RoundedRectangle(cornerRadius: 4))
                    } else {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(Color(NSColor.controlAccentColor))
                            .frame(width: 40, height: 40)
                    }
                    // æ°´å¹³æ»šåŠ¨æ–‡æœ¬å®¹å™¨
                    ScrollView(.horizontal, showsIndicators: false) {
                        Text("\(song.name) - \(song.artist) - \(song.album)")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(Color(NSColor.secondaryLabelColor))
                            .padding(.horizontal, 16)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }
                .frame(height: 42)
                .background(isHovered ? Color.blue.opacity(0.6) : Color.clear)  // æ‚¬åœèƒŒæ™¯
                .cornerRadius(8)
                .contentShape(Rectangle())  // ç¡®ä¿æ•´ä¸ªåŒºåŸŸå¯ç‚¹å‡»
            }
            .buttonStyle(.plain)
            .onHover { hovering in
                withAnimation(.easeInOut(duration: 0.15)) {
                    isHovered = hovering
                }
            }
        }

        private func selectSong() {
            withAnimation {
                viewModel.needNanualSelection = false
                viewModel.onCandidateSelected?(song)
                viewModel.onCandidateSelected = nil
            }
        }
    }
}
